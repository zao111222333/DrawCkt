use std::fs;
use std::path::{Path, PathBuf};

fn main() {
    // Tell Cargo to rerun this build script if the demo directory changes
    println!("cargo:rerun-if-changed=demo");
    
    let demo_dir = Path::new("demo");
    
    let mut entries = Vec::new();
    
    // Read all JSON files from demo directory
    if let Ok(entries_dir) = fs::read_dir(demo_dir) {
        for entry in entries_dir {
            if let Ok(entry) = entry {
                let path = entry.path();
                if path.is_file() {
                    if let Some(ext) = path.extension() {
                        if ext == "json" {
                            if let Some(file_name) = path.file_name() {
                                if let Some(name_str) = file_name.to_str() {
                                    // Get relative path from src/lib.rs to the demo file
                                    // src/lib.rs -> ../demo/filename.json
                                    entries.push((name_str.to_string(), demo_dir.join(name_str)));
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    // Sort entries for consistent output
    entries.sort_by(|a, b| a.0.cmp(&b.0));
    
    // Generate the phf_map code
    let mut map_code = String::from("// Auto-generated by build.rs\n");
    map_code.push_str("static DEMO_FILES: phf::Map<&'static str, &'static str> = phf::phf_map! {\n");
    for (name, path) in &entries {
        map_code.push_str(&format!("    \"{name}\" => include_str!(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/{}\")),", path.display()));
    }
    map_code.push_str("\n};\n");
    // Write the generated file
    fs::write(PathBuf::from(std::env::var("OUT_DIR").unwrap()).join("demo_files.rs"), map_code)
        .expect("Failed to write generated demo files");
}

