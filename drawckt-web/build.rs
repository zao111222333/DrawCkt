use core::fmt;
use drawckt::schematic::{LayerStyle, LayerStyles};
use std::fmt::Write;
use std::fs;
use std::path::{Path, PathBuf};

struct LayerStyleFmt<'a>(&'a LayerStyle);
impl<'a> fmt::Display for LayerStyleFmt<'a> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "drawckt::schematic::LayerStyle::new({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?})",
            self.0.stroke_color,
            self.0.stroke_width,
            self.0.text_color,
            self.0.font_zoom,
            self.0.font_family,
            self.0.label_sch_visible,
            self.0.shape_sch_visible,
        )
    }
}
struct LayerStylesFmt(LayerStyles);
impl fmt::Display for LayerStylesFmt {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "LayerStyles {{")?;
        write!(f, "layer_order: [")?;
        for layer in &self.0.layer_order {
            write!(f, "drawckt::schematic::Layer::{layer:?}, ")?;
        }
        write!(
            f,
            "], device: {}, instance: {}, wire: {}, annotate: {}, pin: {}, text: {}, wire_intersection_scale: {:?}, wire_show_intersection: {:?}}}",
            LayerStyleFmt(&self.0.device),
            LayerStyleFmt(&self.0.instance),
            LayerStyleFmt(&self.0.wire),
            LayerStyleFmt(&self.0.annotate),
            LayerStyleFmt(&self.0.pin),
            LayerStyleFmt(&self.0.text),
            self.0.wire_intersection_scale,
            self.0.wire_show_intersection
        )
    }
}
fn main() {
    // Tell Cargo to rerun this build script if the demo directory changes
    println!("cargo:rerun-if-changed=static/demo");
    println!("cargo:rerun-if-changed=static/style");

    let demo_dir = Path::new("static/demo");
    let style_dir = Path::new("static/style");

    let mut entries = Vec::new();

    // Read all JSON and ZIP files from demo directory
    if let Ok(entries_dir) = fs::read_dir(demo_dir) {
        for entry in entries_dir {
            if let Ok(entry) = entry {
                let path = entry.path();
                if path.is_file() {
                    if let Some(ext) = path.extension() {
                        if ext == "json" || ext == "zip" {
                            if let Some(file_name) = path.file_name() {
                                if let Some(name_str) = file_name.to_str() {
                                    // Get relative path from src/lib.rs to the demo file
                                    // src/lib.rs -> ../static/demo/filename.json or ../static/demo/filename.zip
                                    entries.push((
                                        name_str.to_string(),
                                        path.clone(),
                                        ext == "zip",
                                    ));
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    // Sort entries for consistent output
    entries.sort_by(|a, b| a.0.cmp(&b.0));

    // Generate the demo file names list (only names, not content)
    let mut map_code = String::from("// Auto-generated by build.rs\n");
    map_code.push_str("// Only store demo file names, not file contents\n");
    map_code.push_str("// Files are served statically from /demo/ directory\n");
    map_code.push_str("pub static DEMO_FILE_NAMES: &[&str] = &[\n");
    for (name, _, _) in &entries {
        map_code.push_str(&format!("    \"{name}\",\n"));
    }
    map_code.push_str("];\n");
    // Write the generated file
    fs::write(
        PathBuf::from(std::env::var("OUT_DIR").unwrap()).join("demo_files.rs"),
        map_code,
    )
    .expect("Failed to write generated demo files");

    // Generate styles.rs from static/style JSON files
    let mut style_entries = Vec::new();
    if let Ok(entries_dir) = fs::read_dir(style_dir) {
        for entry in entries_dir {
            if let Ok(entry) = entry {
                let path = entry.path();
                if path.is_file() {
                    if let Some(ext) = path.extension() {
                        if ext == "json" {
                            if let Some(file_name) = path.file_name() {
                                if let Some(name_str) = file_name.to_str() {
                                    let name_without_ext =
                                        name_str.strip_suffix(".json").unwrap_or(name_str);
                                    style_entries
                                        .push((name_without_ext.to_string(), path.clone()));
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    // Sort style entries for consistent output
    style_entries.sort_by(|a, b| a.0.cmp(&b.0));

    // Generate init_styles function
    let mut styles_code = String::from(
        r#"// Auto-generated by build.rs
pub fn init_styles() -> IndexMap<String, LayerStyles> {
    [
"#,
    );

    for (name, path) in &style_entries {
        let json_content = fs::read_to_string(path)
            .expect(&format!("Failed to read style file: {}", path.display()));
        let style: LayerStyles = serde_json::from_str(&json_content)
            .expect(&format!("Failed to parse JSON: {}", path.display()));
        // Generate code for each style
        write!(
            styles_code,
            "        (\"{name}\".to_string(), {}),\n",
            LayerStylesFmt(style)
        )
        .unwrap();
    }
    write!(styles_code, "    ].into_iter().collect()\n}}").unwrap();

    // Write the generated file
    fs::write(
        PathBuf::from(std::env::var("OUT_DIR").unwrap()).join("styles.rs"),
        styles_code,
    )
    .expect("Failed to write generated styles.rs");
}
