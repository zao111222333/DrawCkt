use std::fs;
use std::path::{Path, PathBuf};
use base64::{engine::general_purpose, Engine as _};

fn main() {
    // Tell Cargo to rerun this build script if the demo directory changes
    println!("cargo:rerun-if-changed=demo");

    let demo_dir = Path::new("demo");

    let mut entries = Vec::new();

    // Read all JSON and ZIP files from demo directory
    if let Ok(entries_dir) = fs::read_dir(demo_dir) {
        for entry in entries_dir {
            if let Ok(entry) = entry {
                let path = entry.path();
                if path.is_file() {
                    if let Some(ext) = path.extension() {
                        if ext == "json" || ext == "zip" {
                            if let Some(file_name) = path.file_name() {
                                if let Some(name_str) = file_name.to_str() {
                                    // Get relative path from src/lib.rs to the demo file
                                    // src/lib.rs -> ../demo/filename.json or ../demo/filename.zip
                                    entries.push((name_str.to_string(), path.clone(), ext == "zip"));
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    // Sort entries for consistent output
    entries.sort_by(|a, b| a.0.cmp(&b.0));

    // Generate the phf_map code
    let mut map_code = String::from("// Auto-generated by build.rs\n");
    map_code
        .push_str("static DEMO_FILES: phf::Map<&'static str, &'static str> = phf::phf_map! {\n");
    for (name, path, is_zip) in &entries {
        if *is_zip {
            // For ZIP files, read as binary and encode as base64
            let file_data = fs::read(path).expect(&format!("Failed to read ZIP file: {}", path.display()));
            let base64_data = general_purpose::STANDARD.encode(&file_data);
            map_code.push_str(&format!(
                "    \"{name}\" => \"{base64_data}\",\n"
            ));
        } else {
            // For JSON files, use include_str!
            map_code.push_str(&format!(
                "    \"{name}\" => include_str!(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/{}\")),\n",
                path.display()
            ));
        }
    }
    map_code.push_str("};\n");
    // Write the generated file
    fs::write(
        PathBuf::from(std::env::var("OUT_DIR").unwrap()).join("demo_files.rs"),
        map_code,
    )
    .expect("Failed to write generated demo files");
}
