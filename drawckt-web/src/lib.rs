use drawckt::renderer::Renderer;
use drawckt::schematic::{LayerStyles, Schematic};
use serde::{Deserialize, Serialize};
use std::io::Write;
use std::sync::Mutex;
use wasm_bindgen::prelude::*;
use zip::write::{FileOptions, ZipWriter};
use zip::CompressionMethod;

// Map of demo names to their JSON content (auto-generated by build.rs)
include!(concat!(env!("OUT_DIR"), "/demo_files.rs"));

// Initialize panic hook and logger
#[wasm_bindgen(start)]
pub fn init() {
    console_error_panic_hook::set_once();
    console_log::init_with_level(log::Level::Info).expect("Failed to initialize logger");
}

// WASM-compatible error type
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WasmError {
    pub message: String,
}

impl From<drawckt::DrawcktError> for WasmError {
    fn from(err: drawckt::DrawcktError) -> Self {
        WasmError {
            message: err.to_string(),
        }
    }
}

// State management - store data in WASM
static APP_STATE: Mutex<Option<AppState>> = Mutex::new(None);

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AppState {
    pub schematic: Option<Schematic>,
    pub layer_styles: LayerStyles,
    pub symbol_contexts: SymbolContextsData,
    pub schematic_content: Option<String>,
    pub schematic_filename: Option<String>, // Original filename without extension
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct SymbolContextsData {
    pub symbols: Vec<SymbolData>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SymbolData {
    pub lib: String,
    pub cell: String,
    pub current_idx: usize,
    pub hist_content: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SymbolInfo {
    pub lib: String,
    pub cell: String,
}

impl AppState {
    fn new() -> Self {
        Self {
            schematic: None,
            layer_styles: LayerStyles::default(),
            symbol_contexts: SymbolContextsData::default(),
            schematic_content: None,
            schematic_filename: None,
        }
    }

    fn get_state() -> AppState {
        let mut state = APP_STATE.lock().unwrap();
        if state.is_none() {
            *state = Some(AppState::new());
        }
        state.as_ref().unwrap().clone()
    }

    fn set_state(new_state: AppState) {
        let mut state = APP_STATE.lock().unwrap();
        *state = Some(new_state);
    }
}

// Main API functions
#[wasm_bindgen]
pub fn process_schematic_json(json_str: &str) -> Result<JsValue, JsValue> {
    process_schematic_json_with_filename(json_str, None)
}

#[wasm_bindgen]
pub fn process_schematic_json_with_filename(
    json_str: &str,
    filename: Option<String>,
) -> Result<JsValue, JsValue> {
    log::info!("Processing schematic JSON");

    let schematic: Schematic = serde_json::from_str(json_str)
        .map_err(|e| JsValue::from_str(&format!("Failed to parse JSON: {}", e)))?;

    let mut state = AppState::get_state();
    state.schematic = Some(schematic.clone());

    // Extract filename without extension
    if let Some(ref fname) = filename {
        let filename_without_ext = fname.strip_suffix(".json").unwrap_or(fname).to_string();
        state.schematic_filename = Some(filename_without_ext);
    } else {
        // Use design name as default
        state.schematic_filename = Some(format!(
            "{}_{}",
            schematic.design.lib, schematic.design.cell
        ));
    }

    // Render symbols
    log::info!("Rendering symbols");
    let renderer = Renderer::new(schematic.clone()).with_layer_styles(state.layer_styles.clone());

    let symbol_contexts = renderer
        .render_symbols_file()
        .map_err(|e| JsValue::from_str(&format!("Failed to render symbols: {}", e)))?;

    // Convert SymbolContexts to serializable format
    let mut symbols_data = Vec::new();
    for (symbol_id, content) in symbol_contexts.iter() {
        // Skip invalid symbols (empty lib or cell)
        if symbol_id.lib.is_empty() || symbol_id.cell.is_empty() {
            log::warn!("Skipping symbol with empty lib or cell: {:?}", symbol_id);
            continue;
        }
        symbols_data.push(SymbolData {
            lib: symbol_id.lib.clone(),
            cell: symbol_id.cell.clone(),
            current_idx: 0,
            hist_content: vec![content.clone()],
        });
    }

    state.symbol_contexts = SymbolContextsData {
        symbols: symbols_data.clone(),
    };

    // Render schematic
    log::info!("Rendering schematic");
    let schematic_content = renderer
        .render_schematic_file(&symbol_contexts)
        .map_err(|e| JsValue::from_str(&format!("Failed to render schematic: {}", e)))?;

    state.schematic_content = Some(schematic_content.clone());

    let symbol_count = symbols_data.len();
    AppState::set_state(state);

    let result = serde_wasm_bindgen::to_value(&serde_json::json!({
        "success": true,
        "symbol_count": symbol_count,
        "schematic_rendered": true,
    }))
    .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)))?;

    log::debug!("Schematic processing complete");
    Ok(result)
}

#[wasm_bindgen]
pub fn get_symbol_content(lib: &str, cell: &str) -> Result<JsValue, JsValue> {
    log::debug!("Getting symbol content: {}/{}", lib, cell);

    let state = AppState::get_state();

    for symbol in &state.symbol_contexts.symbols {
        if symbol.lib == lib && symbol.cell == cell {
            if let Some(content) = symbol.hist_content.get(symbol.current_idx) {
                return Ok(JsValue::from_str(content));
            }
        }
    }

    Err(JsValue::from_str(&format!(
        "Symbol {}/{} not found",
        lib, cell
    )))
}

#[wasm_bindgen]
pub fn get_schematic_content() -> Result<JsValue, JsValue> {
    log::debug!("Getting schematic content");

    let state = AppState::get_state();

    match &state.schematic_content {
        Some(content) => Ok(JsValue::from_str(content)),
        None => Err(JsValue::from_str("Schematic not rendered yet")),
    }
}

#[wasm_bindgen]
pub fn get_all_symbols() -> Result<JsValue, JsValue> {
    log::debug!("Getting all symbols");

    let state = AppState::get_state();

    // Filter out invalid symbols and convert to SymbolInfo structs
    let symbols: Vec<SymbolInfo> = state
        .symbol_contexts
        .symbols
        .iter()
        .filter(|s| !s.lib.is_empty() && !s.cell.is_empty())
        .map(|s| SymbolInfo {
            lib: s.lib.clone(),
            cell: s.cell.clone(),
        })
        .collect();

    log::debug!("Returning {} symbols", symbols.len());
    serde_wasm_bindgen::to_value(&symbols)
        .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)))
}

#[wasm_bindgen]
pub fn update_layer_styles(styles_json: &str) -> Result<JsValue, JsValue> {
    log::debug!("Updating layer styles");

    let styles: LayerStyles = serde_json::from_str(styles_json)
        .map_err(|e| JsValue::from_str(&format!("Failed to parse styles JSON: {}", e)))?;

    let mut state = AppState::get_state();

    // Check if only sch_visible changed (across all layers)
    let old_styles = state.layer_styles.clone();
    let only_sch_visible_changed = {
        let check_layer =
            |old: &drawckt::schematic::LayerStyle, new: &drawckt::schematic::LayerStyle| -> bool {
                // Check if only sch_visible changed (other fields unchanged)
                old.stroke_color == new.stroke_color
                    && (old.stroke_width - new.stroke_width).abs() < f64::EPSILON
                    && old.text_color == new.text_color
                    && (old.font_size - new.font_size).abs() < f64::EPSILON
                    && old.priority == new.priority
            };

        // Check if any layer has non-sch_visible changes
        let has_non_sch_visible_changes = !check_layer(&old_styles.wire, &styles.wire)
            || !check_layer(&old_styles.instance, &styles.instance)
            || !check_layer(&old_styles.device, &styles.device)
            || !check_layer(&old_styles.annotate, &styles.annotate)
            || !check_layer(&old_styles.pin, &styles.pin);

        // Only sch_visible changed if no non-sch_visible changes and at least one sch_visible changed
        !has_non_sch_visible_changes
            && (old_styles.wire.sch_visible != styles.wire.sch_visible
                || old_styles.instance.sch_visible != styles.instance.sch_visible
                || old_styles.device.sch_visible != styles.device.sch_visible
                || old_styles.annotate.sch_visible != styles.annotate.sch_visible
                || old_styles.pin.sch_visible != styles.pin.sch_visible)
    };

    state.layer_styles = styles.clone();

    // If schematic exists, re-render based on what changed
    if let Some(ref schematic) = state.schematic {
        let renderer =
            Renderer::new(schematic.clone()).with_layer_styles(state.layer_styles.clone());

        if only_sch_visible_changed {
            // Only sch_visible changed, skip symbol re-rendering
            log::info!("Only sch_visible changed, re-rendering schematic only");

            // Rebuild symbol_contexts from current state for schematic rendering
            use drawckt::renderer::{SymbolContexts, SymbolId};
            let mut symbol_contexts = SymbolContexts::new();
            for symbol_data in &state.symbol_contexts.symbols {
                let symbol_id = SymbolId {
                    lib: symbol_data.lib.clone(),
                    cell: symbol_data.cell.clone(),
                };
                // Use current content from history
                if let Some(current_content) = symbol_data.hist_content.get(symbol_data.current_idx)
                {
                    symbol_contexts.insert(symbol_id, current_content.clone());
                }
            }

            let schematic_content = renderer
                .render_schematic_file(&symbol_contexts)
                .map_err(|e| JsValue::from_str(&format!("Failed to render schematic: {}", e)))?;

            state.schematic_content = Some(schematic_content);
        } else {
            // Other fields changed, re-render symbols and update history
            log::info!("Re-rendering with updated styles");

            let symbol_contexts = renderer
                .render_symbols_file()
                .map_err(|e| JsValue::from_str(&format!("Failed to render symbols: {}", e)))?;

            // Update each symbol's content using the same history management logic as edit
            for (symbol_id, new_content) in symbol_contexts.iter() {
                // Find the corresponding symbol in state
                for symbol_data in &mut state.symbol_contexts.symbols {
                    if symbol_data.lib == symbol_id.lib && symbol_data.cell == symbol_id.cell {
                        // Use the same history management logic as update_symbol_content
                        update_symbol_content_internal(symbol_data, new_content);
                        break;
                    }
                }
            }

            // Rebuild symbol_contexts from updated state for schematic rendering
            use drawckt::renderer::{SymbolContexts, SymbolId};
            let mut updated_symbol_contexts = SymbolContexts::new();
            for symbol_data in &state.symbol_contexts.symbols {
                let symbol_id = SymbolId {
                    lib: symbol_data.lib.clone(),
                    cell: symbol_data.cell.clone(),
                };
                // Use current content from history
                if let Some(current_content) = symbol_data.hist_content.get(symbol_data.current_idx)
                {
                    updated_symbol_contexts.insert(symbol_id, current_content.clone());
                }
            }

            let schematic_content = renderer
                .render_schematic_file(&updated_symbol_contexts)
                .map_err(|e| JsValue::from_str(&format!("Failed to render schematic: {}", e)))?;

            state.schematic_content = Some(schematic_content);
        }
    }

    AppState::set_state(state);

    // Return result indicating if only sch_visible changed
    serde_wasm_bindgen::to_value(&serde_json::json!({
        "success": true,
        "only_sch_visible_changed": only_sch_visible_changed,
    }))
    .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)))
}

#[wasm_bindgen]
pub fn get_layer_styles() -> Result<JsValue, JsValue> {
    let state = AppState::get_state();

    serde_wasm_bindgen::to_value(&state.layer_styles)
        .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)))
}

// Internal helper function to update symbol content with history management
fn update_symbol_content_internal(symbol: &mut SymbolData, content: &str) {
    // Remove all history after current_idx
    symbol.hist_content.truncate(symbol.current_idx + 1);
    // Push new content to history
    symbol.hist_content.push(content.to_string());
    // Update current_idx
    symbol.current_idx += 1;
}

#[wasm_bindgen]
pub fn update_symbol_content(lib: &str, cell: &str, content: &str) -> Result<JsValue, JsValue> {
    log::info!("Updating symbol content: {}/{}", lib, cell);

    let mut state = AppState::get_state();

    // Find and update the symbol with history
    let mut found = false;
    for symbol in &mut state.symbol_contexts.symbols {
        if symbol.lib == lib && symbol.cell == cell {
            update_symbol_content_internal(symbol, content);
            found = true;
            break;
        }
    }

    if !found {
        return Err(JsValue::from_str(&format!(
            "Symbol {}/{} not found",
            lib, cell
        )));
    }

    // Re-render only the updated symbol and schematic
    if let Some(ref schematic) = state.schematic {
        log::info!("Re-rendering symbol and schematic with updated content");
        let renderer =
            Renderer::new(schematic.clone()).with_layer_styles(state.layer_styles.clone());

        // Rebuild symbol_contexts from updated state
        use drawckt::renderer::{SymbolContexts, SymbolId};
        let mut symbol_contexts = SymbolContexts::new();
        for symbol_data in &state.symbol_contexts.symbols {
            let symbol_id = SymbolId {
                lib: symbol_data.lib.clone(),
                cell: symbol_data.cell.clone(),
            };
            // Use current content from history
            if let Some(current_content) = symbol_data.hist_content.get(symbol_data.current_idx) {
                symbol_contexts.insert(symbol_id, current_content.clone());
            }
        }

        // Re-render schematic with updated symbols
        let schematic_content = renderer
            .render_schematic_file(&symbol_contexts)
            .map_err(|e| JsValue::from_str(&format!("Failed to render schematic: {}", e)))?;

        state.schematic_content = Some(schematic_content);
    }

    AppState::set_state(state);

    serde_wasm_bindgen::to_value(&serde_json::json!({
        "success": true,
        "message": format!("Symbol {}/{} updated", lib, cell),
    }))
    .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)))
}

#[wasm_bindgen]
pub fn undo_symbol(lib: &str, cell: &str) -> Result<JsValue, JsValue> {
    log::info!("Undoing symbol: {}/{}", lib, cell);

    let mut state = AppState::get_state();

    // Find and undo the symbol
    let mut found = false;
    for symbol in &mut state.symbol_contexts.symbols {
        if symbol.lib == lib && symbol.cell == cell {
            if symbol.current_idx > 0 {
                symbol.current_idx -= 1;
                found = true;
                break;
            } else {
                return Err(JsValue::from_str(&format!(
                    "Symbol {}/{} has no history to undo",
                    lib, cell
                )));
            }
        }
    }

    if !found {
        return Err(JsValue::from_str(&format!(
            "Symbol {}/{} not found",
            lib, cell
        )));
    }

    // Re-render symbol and schematic
    if let Some(ref schematic) = state.schematic {
        log::info!("Re-rendering symbol and schematic after undo");
        let renderer =
            Renderer::new(schematic.clone()).with_layer_styles(state.layer_styles.clone());

        use drawckt::renderer::{SymbolContexts, SymbolId};
        let mut symbol_contexts = SymbolContexts::new();
        for symbol_data in &state.symbol_contexts.symbols {
            let symbol_id = SymbolId {
                lib: symbol_data.lib.clone(),
                cell: symbol_data.cell.clone(),
            };
            if let Some(current_content) = symbol_data.hist_content.get(symbol_data.current_idx) {
                symbol_contexts.insert(symbol_id, current_content.clone());
            }
        }

        let schematic_content = renderer
            .render_schematic_file(&symbol_contexts)
            .map_err(|e| JsValue::from_str(&format!("Failed to render schematic: {}", e)))?;

        state.schematic_content = Some(schematic_content);
    }

    AppState::set_state(state);

    serde_wasm_bindgen::to_value(&serde_json::json!({
        "success": true,
        "message": format!("Symbol {}/{} undone", lib, cell),
    }))
    .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)))
}

#[wasm_bindgen]
pub fn redo_symbol(lib: &str, cell: &str) -> Result<JsValue, JsValue> {
    log::info!("Redoing symbol: {}/{}", lib, cell);

    let mut state = AppState::get_state();

    // Find and redo the symbol
    let mut found = false;
    for symbol in &mut state.symbol_contexts.symbols {
        if symbol.lib == lib && symbol.cell == cell {
            if symbol.current_idx < symbol.hist_content.len() - 1 {
                symbol.current_idx += 1;
                found = true;
                break;
            } else {
                return Err(JsValue::from_str(&format!(
                    "Symbol {}/{} has no history to redo",
                    lib, cell
                )));
            }
        }
    }

    if !found {
        return Err(JsValue::from_str(&format!(
            "Symbol {}/{} not found",
            lib, cell
        )));
    }

    // Re-render symbol and schematic
    if let Some(ref schematic) = state.schematic {
        log::info!("Re-rendering symbol and schematic after redo");
        let renderer =
            Renderer::new(schematic.clone()).with_layer_styles(state.layer_styles.clone());

        use drawckt::renderer::{SymbolContexts, SymbolId};
        let mut symbol_contexts = SymbolContexts::new();
        for symbol_data in &state.symbol_contexts.symbols {
            let symbol_id = SymbolId {
                lib: symbol_data.lib.clone(),
                cell: symbol_data.cell.clone(),
            };
            if let Some(current_content) = symbol_data.hist_content.get(symbol_data.current_idx) {
                symbol_contexts.insert(symbol_id, current_content.clone());
            }
        }

        let schematic_content = renderer
            .render_schematic_file(&symbol_contexts)
            .map_err(|e| JsValue::from_str(&format!("Failed to render schematic: {}", e)))?;

        state.schematic_content = Some(schematic_content);
    }

    AppState::set_state(state);

    serde_wasm_bindgen::to_value(&serde_json::json!({
        "success": true,
        "message": format!("Symbol {}/{} redone", lib, cell),
    }))
    .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)))
}

#[wasm_bindgen]
pub fn get_symbol_info(lib: &str, cell: &str) -> Result<JsValue, JsValue> {
    log::debug!("Getting symbol info: {}/{}", lib, cell);

    let state = AppState::get_state();

    for symbol in &state.symbol_contexts.symbols {
        if symbol.lib == lib && symbol.cell == cell {
            return serde_wasm_bindgen::to_value(&serde_json::json!({
                "lib": symbol.lib,
                "cell": symbol.cell,
                "current_idx": symbol.current_idx,
                "hist_len": symbol.hist_content.len(),
                "can_undo": symbol.current_idx > 0,
                "can_redo": symbol.current_idx < symbol.hist_content.len() - 1,
            }))
            .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)));
        }
    }

    Err(JsValue::from_str(&format!(
        "Symbol {}/{} not found",
        lib, cell
    )))
}

// Router function for embedded files
#[wasm_bindgen]
pub fn route_embedded(path: &str) -> Result<JsValue, JsValue> {
    log::debug!("Routing embedded path: {}", path);

    // Extract the embedded part from path (supports subfolder deployment)
    // Path might be like /path/to/drawckt/embedded/schematic.drawio
    // or /embedded/schematic.drawio
    let embedded_part = if let Some(idx) = path.rfind("/embedded/") {
        &path[idx..]
    } else if path.starts_with("/embedded/") {
        path
    } else {
        return Err(JsValue::from_str(&format!(
            "Invalid path: no /embedded/ found in {}",
            path
        )));
    };

    // Parse path: /embedded/symbols/{lib}/{cell}.drawio or /embedded/schematic.drawio
    if embedded_part == "/embedded/schematic.drawio"
        || embedded_part.starts_with("/embedded/schematic.drawio")
    {
        return get_schematic_content();
    }

    if embedded_part.starts_with("/embedded/symbols/") {
        // Remove prefix and suffix
        let without_prefix = embedded_part
            .strip_prefix("/embedded/symbols/")
            .ok_or_else(|| JsValue::from_str("Invalid path: missing prefix"))?;

        // Remove .drawio suffix if present
        let without_suffix = if without_prefix.ends_with(".drawio") {
            without_prefix
                .strip_suffix(".drawio")
                .ok_or_else(|| JsValue::from_str("Invalid path: missing suffix"))?
        } else {
            without_prefix
        };

        // Split by '/' to get lib and cell
        let parts: Vec<&str> = without_suffix.split('/').collect();

        log::debug!("Path parts: {:?}, count: {}", parts, parts.len());

        if parts.len() == 2 {
            let lib = parts[0];
            let cell = parts[1];
            log::debug!("Getting symbol: lib={}, cell={}", lib, cell);
            return get_symbol_content(lib, cell);
        } else {
            log::warn!("Invalid path format: expected 2 parts, got {}", parts.len());
            return Err(JsValue::from_str(&format!(
                "Invalid path format: expected lib/cell, got {} parts",
                parts.len()
            )));
        }
    }

    Err(JsValue::from_str(&format!("Unknown path: {}", path)))
}

#[wasm_bindgen]
pub fn get_demo_list() -> Result<JsValue, JsValue> {
    log::debug!("Getting demo list");
    
    let demo_names: Vec<&str> = DEMO_FILES.keys().copied().collect();
    
    serde_wasm_bindgen::to_value(&demo_names)
        .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)))
}

#[wasm_bindgen]
pub fn load_demo(name: &str) -> Result<JsValue, JsValue> {
    log::debug!("Loading demo: {}", name);
    
    let content = DEMO_FILES
        .get(name)
        .ok_or_else(|| JsValue::from_str(&format!("Demo '{}' not found", name)))?;
    
    Ok(JsValue::from_str(content))
}

#[wasm_bindgen]
pub fn export_all_files() -> Result<JsValue, JsValue> {
    log::info!("Exporting all files to ZIP");

    let state = AppState::get_state();

    // Check if schematic is available
    let schematic = state
        .schematic
        .as_ref()
        .ok_or_else(|| JsValue::from_str("No schematic loaded"))?;

    let schematic_content = state
        .schematic_content
        .as_ref()
        .ok_or_else(|| JsValue::from_str("Schematic not rendered"))?;

    // Get filename
    let filename = state
        .schematic_filename
        .as_ref()
        .map(|s| s.clone())
        .unwrap_or_else(|| format!("{}_{}", schematic.design.lib, schematic.design.cell));

    // Create ZIP in memory
    let mut zip_data = Vec::new();
    {
        let mut zip = ZipWriter::new(std::io::Cursor::new(&mut zip_data));
        let options = FileOptions::default()
            .compression_method(CompressionMethod::Deflated)
            .unix_permissions(0o755);

        // Add schematic.json
        let schematic_json = serde_json::to_string_pretty(schematic)
            .map_err(|e| JsValue::from_str(&format!("Failed to serialize schematic: {}", e)))?;
        zip.start_file("schematic.json", options).map_err(|e| {
            JsValue::from_str(&format!("Failed to add schematic.json to ZIP: {}", e))
        })?;
        zip.write_all(schematic_json.as_bytes())
            .map_err(|e| JsValue::from_str(&format!("Failed to write schematic.json: {}", e)))?;

        // Add schematic.drawio
        zip.start_file("schematic.drawio", options).map_err(|e| {
            JsValue::from_str(&format!("Failed to add schematic.drawio to ZIP: {}", e))
        })?;
        zip.write_all(schematic_content.as_bytes())
            .map_err(|e| JsValue::from_str(&format!("Failed to write schematic.drawio: {}", e)))?;

        // Add symbols directory
        for symbol_data in &state.symbol_contexts.symbols {
            // Get current content from history
            if let Some(content) = symbol_data.hist_content.get(symbol_data.current_idx) {
                let symbol_path =
                    format!("symbols/{}/{}.drawio", symbol_data.lib, symbol_data.cell);
                zip.start_file(&symbol_path, options).map_err(|e| {
                    JsValue::from_str(&format!("Failed to add {} to ZIP: {}", symbol_path, e))
                })?;
                zip.write_all(content.as_bytes()).map_err(|e| {
                    JsValue::from_str(&format!("Failed to write {}: {}", symbol_path, e))
                })?;
            }
        }

        zip.finish()
            .map_err(|e| JsValue::from_str(&format!("Failed to finish ZIP: {}", e)))?;
    }

    // Convert to base64 for JavaScript
    use base64::engine::general_purpose;
    use base64::Engine;
    let base64_zip = general_purpose::STANDARD.encode(&zip_data);

    serde_wasm_bindgen::to_value(&serde_json::json!({
        "success": true,
        "filename": format!("{}.zip", filename),
        "data": base64_zip,
    }))
    .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)))
}
