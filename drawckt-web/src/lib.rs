use base64::engine::general_purpose;
use base64::Engine as _;
use drawckt::renderer::{Renderer, SymbolContexts, SymbolId};
use drawckt::schematic::{LayerStyles, Schematic};
use indexmap::IndexMap;
use serde::{Deserialize, Serialize};
use std::borrow::Cow;
use std::collections::HashMap;
use std::io::{Read, Write};
use std::sync::Mutex;
use wasm_bindgen::prelude::*;
use zip::read::ZipArchive;
use zip::write::{FileOptions, ZipWriter};
use zip::CompressionMethod;

// Map of demo names to their JSON content (auto-generated by build.rs)
include!(concat!(env!("OUT_DIR"), "/demo_files.rs"));

// Initialize styles from static/style JSON files (auto-generated by build.rs)
include!(concat!(env!("OUT_DIR"), "/styles.rs"));

// Initialize panic hook and logger
#[wasm_bindgen(start)]
pub fn init() {
    console_error_panic_hook::set_once();
    console_log::init_with_level(log::Level::Info).expect("Failed to initialize logger");
}

// WASM-compatible error type
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WasmError {
    pub message: String,
}

impl From<drawckt::DrawcktError> for WasmError {
    fn from(err: drawckt::DrawcktError) -> Self {
        WasmError {
            message: err.to_string(),
        }
    }
}

// State management - store data in WASM
static APP_STATE: Mutex<Option<AppState>> = Mutex::new(None);

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AppState {
    pub schematic: Option<Schematic>,
    pub styles: StylesState,
    pub symbols: Vec<SymbolData>,
    pub schematic_content: Option<HistoryContent>,
    pub schematic_filename: Option<String>, // Original filename without extension
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StylesState {
    pub current: LayerStyles,
    pub current_name: String,
    pub all: IndexMap<String, LayerStyles>,
}

impl StylesState {
    pub fn new() -> Self {
        let all = init_styles();
        let current_name = "virtuoso".to_string();
        Self {
            current: all[&current_name].clone(),
            current_name,
            all,
        }
    }
    pub fn all_names(&self) -> Vec<String> {
        self.all.keys().cloned().collect()
    }
    pub fn fix_current(&mut self) {
        self.all[&self.current_name] = self.current.clone();
    }
    pub fn add_style(&mut self, name: String, styles: LayerStyles) {
        self.fix_current();
        self.all.insert(name.clone(), styles);
        self.current_name = name;
    }
    pub fn get_current_fixed_style(&self) -> &LayerStyles {
        &self.all[&self.current_name]
    }
    pub fn get_current_style(&self) -> &LayerStyles {
        &self.current
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SymbolData {
    pub lib: String,
    pub cell: String,
    pub history: HistoryContent,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HistoryContent {
    pub current_idx: usize,
    pub hist_content: Vec<String>,
}

impl HistoryContent {
    pub fn new(initial_content: String) -> Self {
        Self {
            current_idx: 0,
            hist_content: vec![initial_content],
        }
    }

    pub fn update(&mut self, content: String) {
        // Remove all history after current_idx
        self.hist_content.truncate(self.current_idx + 1);
        // Push new content to history
        self.hist_content.push(content);
        // Update current_idx
        self.current_idx += 1;
    }

    pub fn undo(&mut self) -> Result<(), String> {
        if self.current_idx > 0 {
            self.current_idx -= 1;
            Ok(())
        } else {
            Err("No history to undo".to_string())
        }
    }

    pub fn redo(&mut self) -> Result<(), String> {
        if self.current_idx < self.hist_content.len() - 1 {
            self.current_idx += 1;
            Ok(())
        } else {
            Err("No history to redo".to_string())
        }
    }

    pub fn get_current(&self) -> Option<&String> {
        self.hist_content.get(self.current_idx)
    }

    pub fn can_undo(&self) -> bool {
        self.current_idx > 0
    }

    pub fn can_redo(&self) -> bool {
        self.current_idx < self.hist_content.len() - 1
    }

    // Helper function to create history zip file
    pub fn hist_zip(&self, base_name: &str) -> Result<Vec<u8>, JsValue> {
        let mut hist_zip_data = Vec::new();
        {
            let mut hist_zip = ZipWriter::new(std::io::Cursor::new(&mut hist_zip_data));
            let options = FileOptions::default()
                .compression_method(CompressionMethod::Deflated)
                .unix_permissions(0o755);

            // Add all history versions
            for (idx, content) in self.hist_content.iter().enumerate() {
                let file_idx = idx + 1; // 1-based index for file names
                let file_name = if idx == self.current_idx {
                    // Rename current version to .current.drawio
                    format!("{}.{}.current.drawio", base_name, file_idx)
                } else {
                    format!("{}.{}.drawio", base_name, file_idx)
                };

                hist_zip.start_file(&file_name, options).map_err(|e| {
                    JsValue::from_str(&format!(
                        "Failed to add {} to history ZIP: {}",
                        file_name, e
                    ))
                })?;
                hist_zip.write_all(content.as_bytes()).map_err(|e| {
                    JsValue::from_str(&format!("Failed to write {}: {}", file_name, e))
                })?;
            }

            hist_zip
                .finish()
                .map_err(|e| JsValue::from_str(&format!("Failed to finish history ZIP: {}", e)))?;
        }
        Ok(hist_zip_data)
    }

    // Restore history from a history zip file
    pub fn from_hist_zip(hist_zip_data: &[u8], base_name: &str) -> Result<Self, JsValue> {
        let cursor = std::io::Cursor::new(hist_zip_data);
        let mut archive = ZipArchive::new(cursor)
            .map_err(|e| JsValue::from_str(&format!("Failed to open history ZIP: {}", e)))?;

        let mut hist_content = Vec::new();
        let mut current_idx = 0;

        // Collect all files and sort by index
        let mut entries: Vec<(usize, String, bool)> = Vec::new();
        for i in 0..archive.len() {
            let file = archive.by_index(i).map_err(|e| {
                JsValue::from_str(&format!(
                    "Failed to read file {} from history ZIP: {}",
                    i, e
                ))
            })?;
            let name = file.name().to_string();

            // Parse filename to extract index and check if it's current
            if name.starts_with(&format!("{}.", base_name)) && name.ends_with(".drawio") {
                let without_ext = name.strip_suffix(".drawio").unwrap();
                let is_current = without_ext.ends_with(".current");
                let index_str = if is_current {
                    without_ext
                        .strip_suffix(".current")
                        .unwrap()
                        .strip_prefix(&format!("{}.", base_name))
                        .unwrap()
                } else {
                    without_ext
                        .strip_prefix(&format!("{}.", base_name))
                        .unwrap()
                };

                if let Ok(file_idx) = index_str.parse::<usize>() {
                    entries.push((file_idx, name, is_current));
                }
            }
        }

        // Sort by index
        entries.sort_by_key(|(idx, _, _)| *idx);

        // Read files in order
        for (file_idx, name, is_current) in entries {
            let mut file = archive.by_name(&name).map_err(|e| {
                JsValue::from_str(&format!("Failed to read {} from history ZIP: {}", name, e))
            })?;
            let mut content = String::new();
            file.read_to_string(&mut content).map_err(|e| {
                JsValue::from_str(&format!("Failed to read content from {}: {}", name, e))
            })?;

            hist_content.push(content);

            // Track current index (0-based, so file_idx - 1)
            if is_current {
                current_idx = file_idx - 1;
            }
        }

        if hist_content.is_empty() {
            return Err(JsValue::from_str("History ZIP contains no valid files"));
        }

        Ok(Self {
            current_idx,
            hist_content,
        })
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SymbolInfo {
    pub lib: String,
    pub cell: String,
}

impl AppState {
    fn new() -> Self {
        Self {
            schematic: None,
            styles: StylesState::new(),
            symbols: Vec::default(),
            schematic_content: None,
            schematic_filename: None,
        }
    }

    fn get_state() -> AppState {
        let mut state = APP_STATE.lock().unwrap();
        if state.is_none() {
            *state = Some(AppState::new());
        }
        state.as_ref().unwrap().clone()
    }

    fn set_state(new_state: AppState) {
        let mut state = APP_STATE.lock().unwrap();
        *state = Some(new_state);
    }

    fn symbol_contents<'a>(&'a self) -> Result<SymbolContexts<'a>, JsValue> {
        Ok(SymbolContexts(
            self.symbols
                .iter()
                .map(|symbol_data| {
                    let symbol_id = SymbolId {
                        lib: symbol_data.lib.as_str().into(),
                        cell: symbol_data.cell.as_str().into(),
                    };
                    Ok((
                        symbol_id,
                        symbol_data
                            .history
                            .get_current()
                            .map(|content| content.as_str().into())
                            .ok_or_else(|| JsValue::from_str("Symbol content not available"))?,
                    ))
                })
                .collect::<Result<_, JsValue>>()?,
        ))
    }
}

// Main API functions
#[wasm_bindgen]
pub fn process_schematic_json(json_str: &str) -> Result<JsValue, JsValue> {
    process_schematic_json_with_filename(json_str, None)
}

#[wasm_bindgen]
pub fn process_schematic_json_with_filename(
    json_str: &str,
    filename: Option<String>,
) -> Result<JsValue, JsValue> {
    log::info!("Processing schematic JSON");

    let schematic: Schematic = serde_json::from_str(json_str)
        .map_err(|e| JsValue::from_str(&format!("Failed to parse JSON: {}", e)))?;

    let mut state = AppState::get_state();

    // Extract filename without extension
    if let Some(ref fname) = filename {
        let filename_without_ext = fname.strip_suffix(".json").unwrap_or(fname).to_string();
        state.schematic_filename = Some(filename_without_ext);
    } else {
        // Use design name as default
        state.schematic_filename = Some(format!(
            "{}_{}",
            schematic.design.lib, schematic.design.cell
        ));
    }

    // Render symbols
    log::info!("Rendering symbols");
    let renderer = Renderer::new(&schematic, state.styles.get_current_style());

    let symbol_contexts = renderer
        .render_symbols_file()
        .map_err(|e| JsValue::from_str(&format!("Failed to render symbols: {}", e)))?;

    // Render schematic
    log::info!("Rendering schematic");
    let schematic_content = renderer
        .render_schematic_file(&symbol_contexts)
        .map_err(|e| JsValue::from_str(&format!("Failed to render schematic: {}", e)))?;

    // Convert SymbolContexts to serializable format
    state.symbols = symbol_contexts
        .0
        .into_iter()
        .filter_map(|(symbol_id, content)| {
            // Skip invalid symbols (empty lib or cell)
            if symbol_id.lib.is_empty() || symbol_id.cell.is_empty() {
                log::warn!("Skipping symbol with empty lib or cell: {:?}", symbol_id);
                None
            } else {
                Some(SymbolData {
                    lib: symbol_id.lib.into_owned(),
                    cell: symbol_id.cell.into_owned(),
                    history: HistoryContent::new(content.into_owned()),
                })
            }
        })
        .collect();
    state.schematic = Some(schematic);
    state.schematic_content = Some(HistoryContent::new(schematic_content));

    let symbol_count = state.symbols.len();
    AppState::set_state(state);

    let result = serde_wasm_bindgen::to_value(&serde_json::json!({
        "success": true,
        "symbol_count": symbol_count,
        "schematic_rendered": true,
    }))
    .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)))?;

    log::debug!("Schematic processing complete");
    Ok(result)
}

#[wasm_bindgen]
pub fn process_schematic_zip(base64_zip: &str) -> Result<JsValue, JsValue> {
    process_schematic_zip_with_filename(base64_zip, None)
}

/// Extract ZIP archive and return file contents
fn extract_zip_contents(
    base64_zip: &str,
) -> Result<(HashMap<String, Vec<u8>>, Option<String>), JsValue> {
    log::info!("Processing schematic ZIP");
    // Decode base64
    let zip_data = general_purpose::STANDARD
        .decode(base64_zip)
        .map_err(|e| JsValue::from_str(&format!("Failed to decode base64 ZIP: {}", e)))?;

    // Open ZIP archive
    let cursor = std::io::Cursor::new(zip_data);
    let mut archive = ZipArchive::new(cursor)
        .map_err(|e| JsValue::from_str(&format!("Failed to open ZIP archive: {}", e)))?;

    // Read all files into memory first to avoid multiple borrows
    let file_contents: HashMap<String, Vec<u8>> = (0..archive.len())
        .into_iter()
        .map(|i| {
            let mut file = archive.by_index(i).map_err(|e| {
                JsValue::from_str(&format!("Failed to read file {} from ZIP: {}", i, e))
            })?;
            let name = file.name().to_string();
            let mut content = Vec::new();
            file.read_to_end(&mut content).map_err(|e| {
                JsValue::from_str(&format!("Failed to read content from {}: {}", name, e))
            })?;
            Ok((name, content))
        })
        .collect::<Result<HashMap<String, Vec<u8>>, JsValue>>()?;
    let base_path = detect_base_path(&file_contents);
    log::info!(
        "Detected base path: '{}'",
        if let Some(path) = &base_path {
            path.as_str()
        } else {
            "root"
        }
    );
    Ok((file_contents, base_path))
}

/// Detect the base path prefix for files in the ZIP
/// Returns the prefix (e.g., "folder/" or "") based on the ZIP structure
/// Supports two formats:
/// 1. Files directly in root: layers.json, schematic.json, ...
/// 2. Files in a subfolder: folder/layers.json, folder/schematic.json, ...
fn detect_base_path(file_contents: &std::collections::HashMap<String, Vec<u8>>) -> Option<String> {
    // Check if files are directly in root
    let root_files = [
        "layers.json",
        "schematic.json",
        "schematic.hist.zip",
        "schematic.drawio",
    ];
    for root_file in &root_files {
        if file_contents.contains_key(*root_file) {
            return None; // Files are in root
        }
    }

    // Check if files are in a subfolder
    // Find the first directory that contains one of our target files
    for name in file_contents.keys() {
        // Skip directories and files in symbols/ folder
        if name.ends_with('/') || name.starts_with("symbols/") {
            continue;
        }

        // Extract the first directory component
        if let Some(first_slash) = name.find('/') {
            let potential_base = &name[..first_slash + 1];
            // Check if this directory contains our target files
            for root_file in &root_files {
                let path_in_dir = format!("{}{}", potential_base, root_file);
                if file_contents.contains_key(&path_in_dir) {
                    return Some(potential_base.to_string());
                }
            }
        }
    }

    // Default: assume files are in root
    None
}

/// Find a file in the ZIP using the base path prefix
fn find_file(
    file_contents: &mut std::collections::HashMap<String, Vec<u8>>,
    base_path: &Option<String>,
    filename: &str,
) -> Option<Vec<u8>> {
    // Try with base path first
    let path_with_base = if let Some(base_path) = base_path {
        Cow::Owned(format!("{}{}", base_path, filename))
    } else {
        Cow::Borrowed(filename)
    };
    if let Some(content) = file_contents.remove(path_with_base.as_ref()) {
        return Some(content);
    }
    // Fallback: try without base path (for root files)
    file_contents.remove(filename)
}

#[wasm_bindgen]
pub fn process_schematic_zip_with_filename(
    base64_zip: &str,
    filename: Option<String>,
) -> Result<JsValue, JsValue> {
    let (mut file_contents, base_path) = extract_zip_contents(base64_zip)?;
    let mut state = AppState::new();

    // Read styles from /styles directory
    // First, try to read /styles/{current_name}.json for current style
    // Then read /styles/all/{name}.json for all styles
    let mut styles_state = StylesState::new();

    // Collect style file names first to avoid borrow checker issues
    let mut all_style_files = Vec::new();
    let mut current_style_file = None;
    for name in file_contents.keys() {
        if name.starts_with("styles/all/") && name.ends_with(".json") {
            all_style_files.push(name.clone());
        } else if name.starts_with("styles/")
            && name.ends_with(".json")
            && !name.starts_with("styles/all/")
        {
            current_style_file = Some(name.clone());
        }
    }

    // Read all styles from /styles/all/ directory
    let mut all_styles = IndexMap::new();
    for name in &all_style_files {
        if let Some(name_without_ext) = name
            .strip_prefix("styles/all/")
            .and_then(|s| s.strip_suffix(".json"))
        {
            if let Some(content) = find_file(&mut file_contents, &base_path, name) {
                let style_json = String::from_utf8(content)
                    .map_err(|e| JsValue::from_str(&format!("Failed to decode {}: {}", name, e)))?;
                let layer_styles: LayerStyles = serde_json::from_str(&style_json)
                    .map_err(|e| JsValue::from_str(&format!("Failed to parse {}: {}", name, e)))?;
                all_styles.insert(name_without_ext.to_string(), layer_styles);
            }
        }
    }

    // If we found styles in /styles/all/, use them
    if !all_styles.is_empty() {
        styles_state.all = all_styles;
    }

    // Try to read current style from /styles/{current_name}.json
    if let Some(name) = current_style_file {
        if let Some(name_without_ext) = name
            .strip_prefix("styles/")
            .and_then(|s| s.strip_suffix(".json"))
        {
            if let Some(content) = find_file(&mut file_contents, &base_path, &name) {
                let style_json = String::from_utf8(content)
                    .map_err(|e| JsValue::from_str(&format!("Failed to decode {}: {}", name, e)))?;
                let layer_styles: LayerStyles = serde_json::from_str(&style_json)
                    .map_err(|e| JsValue::from_str(&format!("Failed to parse {}: {}", name, e)))?;
                let current_name = name_without_ext.to_string();
                styles_state.current = layer_styles.clone();
                styles_state.current_name = current_name.clone();
                // Also add to all if not present
                if !styles_state.all.contains_key(&current_name) {
                    styles_state.all.insert(current_name, layer_styles);
                }
            }
        }
    }

    // Fallback: if no styles found, try old layers.json format
    if styles_state.all.is_empty() {
        if let Some(layers_data) = find_file(&mut file_contents, &base_path, "layers.json") {
            let layers_json = String::from_utf8(layers_data)
                .map_err(|e| JsValue::from_str(&format!("Failed to decode layers.json: {}", e)))?;
            let layer_styles: LayerStyles = serde_json::from_str(&layers_json)
                .map_err(|e| JsValue::from_str(&format!("Failed to parse layers.json: {}", e)))?;
            styles_state.current = layer_styles.clone();
            styles_state.current_name = "custom".to_string();
            styles_state.all.insert("custom".to_string(), layer_styles);
            log::info!("Restored layer styles from old layers.json format");
        }
    } else {
        log::info!("Restored styles from /styles directory");
    }

    state.styles = styles_state;

    // Read schematic.json
    let schematic_data = find_file(&mut file_contents, &base_path, "schematic.json")
        .ok_or_else(|| JsValue::from_str("Failed to find schematic.json in ZIP"))?;
    let schematic_json = String::from_utf8(schematic_data)
        .map_err(|e| JsValue::from_str(&format!("Failed to decode schematic.json: {}", e)))?;
    let schematic: Schematic = serde_json::from_str(&schematic_json)
        .map_err(|e| JsValue::from_str(&format!("Failed to parse schematic.json: {}", e)))?;

    // Extract filename
    if let Some(ref fname) = filename {
        let filename_without_ext = fname
            .strip_suffix(".zip")
            .or_else(|| fname.strip_suffix(".json"))
            .unwrap_or(fname)
            .to_string();
        state.schematic_filename = Some(filename_without_ext);
    } else {
        state.schematic_filename = Some(format!(
            "{}_{}",
            schematic.design.lib, schematic.design.cell
        ));
    }

    // Read schematic.hist.zip if present
    if let Some(hist_zip_data) = find_file(&mut file_contents, &base_path, "schematic.hist.zip") {
        state.schematic_content = Some(HistoryContent::from_hist_zip(&hist_zip_data, "schematic")?);
        log::info!("Restored schematic history from ZIP");
    } else if let Some(drawio_content) =
        find_file(&mut file_contents, &base_path, "schematic.drawio")
    {
        // Fallback: read schematic.drawio if hist.zip is not available
        let drawio_str = String::from_utf8(drawio_content)
            .map_err(|e| JsValue::from_str(&format!("Failed to decode schematic.drawio: {}", e)))?;
        state.schematic_content = Some(HistoryContent::new(drawio_str));
        log::info!("Restored schematic from schematic.drawio (no history)");
    }

    state.symbols = schematic
        .symbols
        .iter()
        .map(|symbol| {
            let lib = symbol.lib.clone();
            let cell = symbol.cell.clone();
            // Read symbol drawio file
            // find_file will try base_path + symbols/lib/cell.drawio first, then symbols/lib/cell.drawio
            let symbol_path = format!("symbols/{}/{}.drawio", lib, cell);
            let symbol_content = find_file(&mut file_contents, &base_path, &symbol_path)
                .ok_or_else(|| {
                    JsValue::from_str(&format!("Failed to find {} in ZIP", symbol_path))
                })?;
            let symbol_content_str = String::from_utf8(symbol_content).map_err(|e| {
                JsValue::from_str(&format!("Failed to decode {}: {}", symbol_path, e))
            })?;
            // Read symbol history zip if present
            let hist_zip_path = format!("symbols/{}/{}.hist.zip", lib, cell);
            let history = if let Some(hist_zip_data) =
                find_file(&mut file_contents, &base_path, &hist_zip_path)
            {
                HistoryContent::from_hist_zip(&hist_zip_data, &cell)?
            } else {
                // Fallback: use drawio content as initial history
                HistoryContent::new(symbol_content_str)
            };
            Ok(SymbolData { lib, cell, history })
        })
        .collect::<Result<Vec<SymbolData>, JsValue>>()?;
    state.schematic = Some(schematic);

    let result = serde_wasm_bindgen::to_value(&serde_json::json!({
        "success": true,
        "symbol_count": state.symbols.len(),
        "schematic_restored": true,
    }))
    .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)))?;
    AppState::set_state(state);
    log::debug!("Schematic ZIP processing complete");
    Ok(result)
}

#[wasm_bindgen]
pub fn get_symbol_content(lib: &str, cell: &str) -> Result<JsValue, JsValue> {
    log::debug!("Getting symbol content: {}/{}", lib, cell);

    let state = AppState::get_state();

    for symbol in &state.symbols {
        if symbol.lib == lib && symbol.cell == cell {
            if let Some(content) = symbol.history.get_current() {
                return Ok(JsValue::from_str(content));
            }
        }
    }

    Err(JsValue::from_str(&format!(
        "Symbol {}/{} not found",
        lib, cell
    )))
}

#[wasm_bindgen]
pub fn get_schematic_content() -> Result<JsValue, JsValue> {
    log::debug!("Getting schematic content");

    let state = AppState::get_state();

    match &state.schematic_content {
        Some(history) => {
            if let Some(content) = history.get_current() {
                Ok(JsValue::from_str(content))
            } else {
                Err(JsValue::from_str("Schematic content not available"))
            }
        }
        None => Err(JsValue::from_str("Schematic not rendered yet")),
    }
}

#[wasm_bindgen]
pub fn get_all_symbols() -> Result<JsValue, JsValue> {
    log::debug!("Getting all symbols");

    let state = AppState::get_state();

    // Filter out invalid symbols and convert to SymbolInfo structs
    let symbols: Vec<SymbolInfo> = state
        .symbols
        .iter()
        .filter(|s| !s.lib.is_empty() && !s.cell.is_empty())
        .map(|s| SymbolInfo {
            lib: s.lib.clone(),
            cell: s.cell.clone(),
        })
        .collect();

    log::debug!("Returning {} symbols", symbols.len());
    serde_wasm_bindgen::to_value(&symbols)
        .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)))
}

#[wasm_bindgen]
pub fn update_layer_styles(styles_json: &str) -> Result<JsValue, JsValue> {
    log::debug!("Updating layer styles");

    let styles: LayerStyles = serde_json::from_str(styles_json)
        .map_err(|e| JsValue::from_str(&format!("Failed to parse styles JSON: {}", e)))?;

    let mut state = AppState::get_state();

    // Check if only sch_visible changed (across all layers)
    let old_styles = state.styles.get_current_style();
    let only_sch_visible_changed = {
        let check_layer =
            |old: &drawckt::schematic::LayerStyle, new: &drawckt::schematic::LayerStyle| -> bool {
                // Check if only sch_visible changed (other fields unchanged)
                old.stroke_color == new.stroke_color
                    && (old.stroke_width - new.stroke_width).abs() < f64::EPSILON
                    && old.text_color == new.text_color
                    && old.font_family == new.font_family
                    && (old.font_zoom - new.font_zoom).abs() < f64::EPSILON
            };

        // Check if any layer has non-sch_visible changes
        let has_non_sch_visible_changes = !check_layer(&old_styles.wire, &styles.wire)
            || !check_layer(&old_styles.instance, &styles.instance)
            || !check_layer(&old_styles.device, &styles.device)
            || !check_layer(&old_styles.annotate, &styles.annotate)
            || !check_layer(&old_styles.pin, &styles.pin);

        // Only sch_visible changed if no non-sch_visible changes and at least one sch_visible changed
        !has_non_sch_visible_changes
            && (old_styles.wire.sch_visible != styles.wire.sch_visible
                || old_styles.instance.sch_visible != styles.instance.sch_visible
                || old_styles.device.sch_visible != styles.device.sch_visible
                || old_styles.annotate.sch_visible != styles.annotate.sch_visible
                || old_styles.pin.sch_visible != styles.pin.sch_visible)
    };

    // Update current style
    state.styles.current = styles;

    // If schematic exists, re-render based on what changed
    if let Some(schematic) = &state.schematic {
        let renderer = Renderer::new(&schematic, state.styles.get_current_style());

        if only_sch_visible_changed {
            // Only sch_visible changed, skip symbol re-rendering
            log::info!("Only sch_visible changed, re-rendering schematic only");

            let schematic_content = renderer
                .render_schematic_file(&state.symbol_contents()?)
                .map_err(|e| JsValue::from_str(&format!("Failed to render schematic: {}", e)))?;

            // Update schematic history
            state.update_schematic_content(schematic_content);
        } else {
            // Other fields changed, re-render symbols and update history
            log::info!("Re-rendering with updated styles");

            let symbol_contexts = renderer
                .render_symbols_file()
                .map_err(|e| JsValue::from_str(&format!("Failed to render symbols: {}", e)))?;

            // Update each symbol's content using the same history management logic as edit
            for (symbol_id, new_content) in symbol_contexts.0 {
                // Find the corresponding symbol in state
                for symbol_data in &mut state.symbols {
                    if symbol_data.lib == symbol_id.lib && symbol_data.cell == symbol_id.cell {
                        // Use the same history management logic as update_symbol_content
                        symbol_data.history.update(new_content.into_owned());
                        break;
                    }
                }
            }

            let schematic_content = renderer
                .render_schematic_file(&state.symbol_contents()?)
                .map_err(|e| JsValue::from_str(&format!("Failed to render schematic: {}", e)))?;

            // Update schematic history
            state.update_schematic_content(schematic_content);
        }
    }

    AppState::set_state(state);

    // Return result indicating if only sch_visible changed
    serde_wasm_bindgen::to_value(&serde_json::json!({
        "success": true,
        "only_sch_visible_changed": only_sch_visible_changed,
    }))
    .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)))
}

#[wasm_bindgen]
pub fn get_layer_styles() -> Result<JsValue, JsValue> {
    let state = AppState::get_state();

    serde_wasm_bindgen::to_value(state.styles.get_current_style())
        .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)))
}

#[wasm_bindgen]
pub fn get_current_fixed_layer_styles() -> Result<JsValue, JsValue> {
    let state = AppState::get_state();

    serde_wasm_bindgen::to_value(state.styles.get_current_fixed_style())
        .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)))
}

#[wasm_bindgen]
pub fn update_symbol_content(lib: &str, cell: &str, content: String) -> Result<JsValue, JsValue> {
    log::info!("Updating symbol content: {}/{}", lib, cell);

    let mut state = AppState::get_state();

    // Find and update the symbol with history
    let mut found = false;
    for symbol in &mut state.symbols {
        if symbol.lib == lib && symbol.cell == cell {
            symbol.history.update(content);
            found = true;
            break;
        }
    }

    if !found {
        return Err(JsValue::from_str(&format!(
            "Symbol {}/{} not found",
            lib, cell
        )));
    }

    // Re-render only the updated symbol and schematic
    if let Some(schematic) = &state.schematic {
        log::info!("Re-rendering symbol and schematic with updated content");
        let renderer = Renderer::new(&schematic, state.styles.get_current_style());

        // Rebuild symbol_contexts from updated state
        // Re-render schematic with updated symbols
        let schematic_content = renderer
            .render_schematic_file(&state.symbol_contents()?)
            .map_err(|e| JsValue::from_str(&format!("Failed to render schematic: {}", e)))?;

        // Update schematic history
        state.update_schematic_content(schematic_content);
    }

    AppState::set_state(state);

    serde_wasm_bindgen::to_value(&serde_json::json!({
        "success": true,
        "message": format!("Symbol {}/{} updated", lib, cell),
    }))
    .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)))
}

#[wasm_bindgen]
pub fn undo_symbol(lib: &str, cell: &str) -> Result<JsValue, JsValue> {
    log::info!("Undoing symbol: {}/{}", lib, cell);

    let mut state = AppState::get_state();

    // Find and undo the symbol
    let mut found = false;
    for symbol in &mut state.symbols {
        if symbol.lib == lib && symbol.cell == cell {
            match symbol.history.undo() {
                Ok(_) => {
                    found = true;
                    break;
                }
                Err(e) => {
                    return Err(JsValue::from_str(&format!(
                        "Symbol {}/{}: {}",
                        lib, cell, e
                    )));
                }
            }
        }
    }

    if !found {
        return Err(JsValue::from_str(&format!(
            "Symbol {}/{} not found",
            lib, cell
        )));
    }

    // Re-render symbol and schematic
    if let Some(ref schematic) = state.schematic {
        log::info!("Re-rendering symbol and schematic after undo");
        let renderer = Renderer::new(&schematic, state.styles.get_current_style());

        let schematic_content = renderer
            .render_schematic_file(&state.symbol_contents()?)
            .map_err(|e| JsValue::from_str(&format!("Failed to render schematic: {}", e)))?;

        // Update schematic history
        state.update_schematic_content(schematic_content);
    }

    AppState::set_state(state);

    serde_wasm_bindgen::to_value(&serde_json::json!({
        "success": true,
        "message": format!("Symbol {}/{} undone", lib, cell),
    }))
    .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)))
}

#[wasm_bindgen]
pub fn redo_symbol(lib: &str, cell: &str) -> Result<JsValue, JsValue> {
    log::info!("Redoing symbol: {}/{}", lib, cell);

    let mut state = AppState::get_state();

    // Find and redo the symbol
    let mut found = false;
    for symbol in &mut state.symbols {
        if symbol.lib == lib && symbol.cell == cell {
            match symbol.history.redo() {
                Ok(_) => {
                    found = true;
                    break;
                }
                Err(e) => {
                    return Err(JsValue::from_str(&format!(
                        "Symbol {}/{}: {}",
                        lib, cell, e
                    )));
                }
            }
        }
    }

    if !found {
        return Err(JsValue::from_str(&format!(
            "Symbol {}/{} not found",
            lib, cell
        )));
    }

    // Re-render symbol and schematic
    if let Some(ref schematic) = state.schematic {
        log::info!("Re-rendering symbol and schematic after redo");
        let renderer = Renderer::new(&schematic, state.styles.get_current_style());

        let schematic_content = renderer
            .render_schematic_file(&state.symbol_contents()?)
            .map_err(|e| JsValue::from_str(&format!("Failed to render schematic: {}", e)))?;

        // Update schematic history
        state.update_schematic_content(schematic_content);
    }

    AppState::set_state(state);

    serde_wasm_bindgen::to_value(&serde_json::json!({
        "success": true,
        "message": format!("Symbol {}/{} redone", lib, cell),
    }))
    .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)))
}

#[wasm_bindgen]
pub fn get_symbol_info(lib: &str, cell: &str) -> Result<JsValue, JsValue> {
    log::debug!("Getting symbol info: {}/{}", lib, cell);

    let state = AppState::get_state();

    for symbol in &state.symbols {
        if symbol.lib == lib && symbol.cell == cell {
            return serde_wasm_bindgen::to_value(&serde_json::json!({
                "lib": symbol.lib,
                "cell": symbol.cell,
                "current_idx": symbol.history.current_idx,
                "hist_len": symbol.history.hist_content.len(),
                "can_undo": symbol.history.can_undo(),
                "can_redo": symbol.history.can_redo(),
            }))
            .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)));
        }
    }

    Err(JsValue::from_str(&format!(
        "Symbol {}/{} not found",
        lib, cell
    )))
}

impl AppState {
    fn update_schematic_content(&mut self, content: String) {
        log::info!("Updating schematic content");

        // Update schematic history
        if let Some(schematic_history) = &mut self.schematic_content {
            schematic_history.update(content);
        } else {
            self.schematic_content = Some(HistoryContent::new(content));
        }
    }
}

#[wasm_bindgen]
pub fn update_schematic_content(content: String) -> Result<JsValue, JsValue> {
    let mut state = AppState::get_state();
    state.update_schematic_content(content);
    AppState::set_state(state);

    serde_wasm_bindgen::to_value(&serde_json::json!({
        "success": true,
        "message": "Schematic updated",
    }))
    .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)))
}

#[wasm_bindgen]
pub fn undo_schematic() -> Result<JsValue, JsValue> {
    log::info!("Undoing schematic");

    let mut state = AppState::get_state();

    match state.schematic_content.as_mut() {
        Some(history) => {
            history
                .undo()
                .map_err(|e| JsValue::from_str(&format!("Failed to undo: {}", e)))?;
        }
        None => {
            return Err(JsValue::from_str("Schematic not rendered yet"));
        }
    }

    // Content is already in history, no need to re-render

    AppState::set_state(state);

    serde_wasm_bindgen::to_value(&serde_json::json!({
        "success": true,
        "message": "Schematic undone",
    }))
    .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)))
}

#[wasm_bindgen]
pub fn redo_schematic() -> Result<JsValue, JsValue> {
    log::info!("Redoing schematic");

    let mut state = AppState::get_state();

    match state.schematic_content.as_mut() {
        Some(history) => {
            history
                .redo()
                .map_err(|e| JsValue::from_str(&format!("Failed to redo: {}", e)))?;
        }
        None => {
            return Err(JsValue::from_str("Schematic not rendered yet"));
        }
    }

    // Content is already in history, no need to re-render

    AppState::set_state(state);

    serde_wasm_bindgen::to_value(&serde_json::json!({
        "success": true,
        "message": "Schematic redone",
    }))
    .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)))
}

#[wasm_bindgen]
pub fn get_schematic_info() -> Result<JsValue, JsValue> {
    log::debug!("Getting schematic info");

    let state = AppState::get_state();

    match &state.schematic_content {
        Some(history) => serde_wasm_bindgen::to_value(&serde_json::json!({
            "current_idx": history.current_idx,
            "hist_len": history.hist_content.len(),
            "can_undo": history.can_undo(),
            "can_redo": history.can_redo(),
        }))
        .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e))),
        None => Err(JsValue::from_str("Schematic not rendered yet")),
    }
}

#[wasm_bindgen]
pub fn get_styles_state() -> Result<JsValue, JsValue> {
    let state = AppState::get_state();
    serde_wasm_bindgen::to_value(&state.styles)
        .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)))
}

#[wasm_bindgen]
pub fn get_all_style_names() -> Result<JsValue, JsValue> {
    let state = AppState::get_state();
    serde_wasm_bindgen::to_value(&state.styles.all_names())
        .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)))
}

#[wasm_bindgen]
pub fn set_current_style(name: &str) -> Result<JsValue, JsValue> {
    let mut state = AppState::get_state();

    if !state.styles.all.contains_key(name) {
        return Err(JsValue::from_str(&format!("Style '{}' not found", name)));
    }

    state.styles.fix_current();
    state.styles.current = state.styles.all[name].clone();
    state.styles.current_name = name.to_string();

    // Re-render if schematic exists
    if let Some(schematic) = &state.schematic {
        let renderer = Renderer::new(&schematic, state.styles.get_current_style());

        let symbol_contexts = renderer
            .render_symbols_file()
            .map_err(|e| JsValue::from_str(&format!("Failed to render symbols: {}", e)))?;

        // Update each symbol's content
        for (symbol_id, new_content) in symbol_contexts.0 {
            for symbol_data in &mut state.symbols {
                if symbol_data.lib == symbol_id.lib && symbol_data.cell == symbol_id.cell {
                    symbol_data.history.update(new_content.into_owned());
                    break;
                }
            }
        }

        let schematic_content = renderer
            .render_schematic_file(&state.symbol_contents()?)
            .map_err(|e| JsValue::from_str(&format!("Failed to render schematic: {}", e)))?;

        state.update_schematic_content(schematic_content);
    }

    AppState::set_state(state);

    serde_wasm_bindgen::to_value(&serde_json::json!({
        "success": true,
    }))
    .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)))
}

#[wasm_bindgen]
pub fn add_style(name: &str, styles_json: &str) -> Result<JsValue, JsValue> {
    let styles: LayerStyles = serde_json::from_str(styles_json)
        .map_err(|e| JsValue::from_str(&format!("Failed to parse styles JSON: {}", e)))?;

    let mut state = AppState::get_state();
    state.styles.add_style(name.to_string(), styles);

    // Re-render if schematic exists
    if let Some(schematic) = &state.schematic {
        let renderer = Renderer::new(&schematic, state.styles.get_current_style());

        let symbol_contexts = renderer
            .render_symbols_file()
            .map_err(|e| JsValue::from_str(&format!("Failed to render symbols: {}", e)))?;

        // Update each symbol's content
        for (symbol_id, new_content) in symbol_contexts.0 {
            for symbol_data in &mut state.symbols {
                if symbol_data.lib == symbol_id.lib && symbol_data.cell == symbol_id.cell {
                    symbol_data.history.update(new_content.into_owned());
                    break;
                }
            }
        }

        let schematic_content = renderer
            .render_schematic_file(&state.symbol_contents()?)
            .map_err(|e| JsValue::from_str(&format!("Failed to render schematic: {}", e)))?;

        state.update_schematic_content(schematic_content);
    }

    AppState::set_state(state);

    serde_wasm_bindgen::to_value(&serde_json::json!({
        "success": true,
    }))
    .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)))
}

#[wasm_bindgen]
pub fn reset_current_style() -> Result<JsValue, JsValue> {
    let mut state = AppState::get_state();
    state.styles.current = state.styles.get_current_fixed_style().clone();

    // Re-render if schematic exists
    if let Some(schematic) = &state.schematic {
        let renderer = Renderer::new(&schematic, state.styles.get_current_style());

        let schematic_content = renderer
            .render_schematic_file(&state.symbol_contents()?)
            .map_err(|e| JsValue::from_str(&format!("Failed to render schematic: {}", e)))?;

        state.update_schematic_content(schematic_content);
    }

    AppState::set_state(state);

    serde_wasm_bindgen::to_value(&serde_json::json!({
        "success": true,
    }))
    .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)))
}

#[wasm_bindgen]
pub fn fix_current_style() -> Result<JsValue, JsValue> {
    let mut state = AppState::get_state();
    state.styles.fix_current();
    AppState::set_state(state);

    serde_wasm_bindgen::to_value(&serde_json::json!({
        "success": true,
    }))
    .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)))
}

// Router function for embedded files
#[wasm_bindgen]
pub fn route_embedded(path: &str) -> Result<JsValue, JsValue> {
    log::debug!("Routing embedded path: {}", path);

    // Extract the embedded part from path (supports subfolder deployment)
    // Path might be like /path/to/drawckt/embedded/schematic.drawio
    // or /embedded/schematic.drawio
    let embedded_part = if let Some(idx) = path.rfind("/embedded/") {
        &path[idx..]
    } else if path.starts_with("/embedded/") {
        path
    } else {
        return Err(JsValue::from_str(&format!(
            "Invalid path: no /embedded/ found in {}",
            path
        )));
    };

    // Parse path: /embedded/symbols/{lib}/{cell}.drawio or /embedded/schematic.drawio
    if embedded_part == "/embedded/schematic.drawio"
        || embedded_part.starts_with("/embedded/schematic.drawio")
    {
        return get_schematic_content();
    }

    if embedded_part.starts_with("/embedded/symbols/") {
        // Remove prefix and suffix
        let without_prefix = embedded_part
            .strip_prefix("/embedded/symbols/")
            .ok_or_else(|| JsValue::from_str("Invalid path: missing prefix"))?;

        // Remove .drawio suffix if present
        let without_suffix = if without_prefix.ends_with(".drawio") {
            without_prefix
                .strip_suffix(".drawio")
                .ok_or_else(|| JsValue::from_str("Invalid path: missing suffix"))?
        } else {
            without_prefix
        };

        // Split by '/' to get lib and cell
        let parts: Vec<&str> = without_suffix.split('/').collect();

        log::debug!("Path parts: {:?}, count: {}", parts, parts.len());

        if parts.len() == 2 {
            let lib = parts[0];
            let cell = parts[1];
            log::debug!("Getting symbol: lib={}, cell={}", lib, cell);
            return get_symbol_content(lib, cell);
        } else {
            log::warn!("Invalid path format: expected 2 parts, got {}", parts.len());
            return Err(JsValue::from_str(&format!(
                "Invalid path format: expected lib/cell, got {} parts",
                parts.len()
            )));
        }
    }

    Err(JsValue::from_str(&format!("Unknown path: {}", path)))
}

#[wasm_bindgen]
pub fn get_demo_list() -> Result<JsValue, JsValue> {
    log::debug!("Getting demo list");

    let demo_names: Vec<&str> = DEMO_FILES.keys().copied().collect();

    serde_wasm_bindgen::to_value(&demo_names)
        .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)))
}

#[wasm_bindgen]
pub fn load_demo(name: &str) -> Result<JsValue, JsValue> {
    log::debug!("Loading demo: {}", name);

    let content = DEMO_FILES
        .get(name)
        .ok_or_else(|| JsValue::from_str(&format!("Demo '{}' not found", name)))?;

    Ok(JsValue::from_str(content))
}

#[wasm_bindgen]
pub fn export_all_files() -> Result<JsValue, JsValue> {
    log::info!("Exporting all files to ZIP");

    let state = AppState::get_state();

    // Check if schematic is available
    let schematic = state
        .schematic
        .as_ref()
        .ok_or_else(|| JsValue::from_str("No schematic loaded"))?;

    let schematic_content = state
        .schematic_content
        .as_ref()
        .and_then(|h| h.get_current())
        .ok_or_else(|| JsValue::from_str("Schematic not rendered"))?;

    // Get filename
    let filename = state
        .schematic_filename
        .as_ref()
        .map(|s| s.clone())
        .unwrap_or_else(|| format!("{}_{}", schematic.design.lib, schematic.design.cell));

    // Create ZIP in memory
    let mut zip_data = Vec::new();
    {
        let mut zip = ZipWriter::new(std::io::Cursor::new(&mut zip_data));
        let options = FileOptions::default()
            .compression_method(CompressionMethod::Deflated)
            .unix_permissions(0o755);

        // Add styles to /styles directory
        // Save current style as /styles/{current_name}.json
        let current_style_json = serde_json::to_string_pretty(state.styles.get_current_style())
            .map_err(|e| JsValue::from_str(&format!("Failed to serialize current style: {}", e)))?;
        let current_style_path = format!("styles/{}.json", state.styles.current_name);
        zip.start_file(&current_style_path, options).map_err(|e| {
            JsValue::from_str(&format!(
                "Failed to add {} to ZIP: {}",
                current_style_path, e
            ))
        })?;
        zip.write_all(current_style_json.as_bytes()).map_err(|e| {
            JsValue::from_str(&format!("Failed to write {}: {}", current_style_path, e))
        })?;

        // Save all styles to /styles/all/{name}.json
        for (name, style) in &state.styles.all {
            let style_json = serde_json::to_string_pretty(style).map_err(|e| {
                JsValue::from_str(&format!("Failed to serialize style {}: {}", name, e))
            })?;
            let style_path = format!("styles/all/{}.json", name);
            zip.start_file(&style_path, options).map_err(|e| {
                JsValue::from_str(&format!("Failed to add {} to ZIP: {}", style_path, e))
            })?;
            zip.write_all(style_json.as_bytes()).map_err(|e| {
                JsValue::from_str(&format!("Failed to write {}: {}", style_path, e))
            })?;
        }

        // Add schematic.json
        let schematic_json = serde_json::to_string_pretty(schematic)
            .map_err(|e| JsValue::from_str(&format!("Failed to serialize schematic: {}", e)))?;
        zip.start_file("schematic.json", options).map_err(|e| {
            JsValue::from_str(&format!("Failed to add schematic.json to ZIP: {}", e))
        })?;
        zip.write_all(schematic_json.as_bytes())
            .map_err(|e| JsValue::from_str(&format!("Failed to write schematic.json: {}", e)))?;

        // Add schematic.drawio
        zip.start_file("schematic.drawio", options).map_err(|e| {
            JsValue::from_str(&format!("Failed to add schematic.drawio to ZIP: {}", e))
        })?;
        zip.write_all(schematic_content.as_bytes())
            .map_err(|e| JsValue::from_str(&format!("Failed to write schematic.drawio: {}", e)))?;

        // Add schematic.hist.zip
        if let Some(schematic_history) = &state.schematic_content {
            let hist_zip_data = schematic_history.hist_zip("schematic")?;
            zip.start_file("schematic.hist.zip", options).map_err(|e| {
                JsValue::from_str(&format!("Failed to add schematic.hist.zip to ZIP: {}", e))
            })?;
            zip.write_all(&hist_zip_data).map_err(|e| {
                JsValue::from_str(&format!("Failed to write schematic.hist.zip: {}", e))
            })?;
        }

        // Add symbols directory
        for symbol_data in &state.symbols {
            // Get current content from history
            if let Some(content) = symbol_data.history.get_current() {
                let symbol_path =
                    format!("symbols/{}/{}.drawio", symbol_data.lib, symbol_data.cell);
                zip.start_file(&symbol_path, options).map_err(|e| {
                    JsValue::from_str(&format!("Failed to add {} to ZIP: {}", symbol_path, e))
                })?;
                zip.write_all(content.as_bytes()).map_err(|e| {
                    JsValue::from_str(&format!("Failed to write {}: {}", symbol_path, e))
                })?;

                // Add symbol history zip
                let hist_zip_data = symbol_data.history.hist_zip(&symbol_data.cell)?;
                let hist_zip_path =
                    format!("symbols/{}/{}.hist.zip", symbol_data.lib, symbol_data.cell);
                zip.start_file(&hist_zip_path, options).map_err(|e| {
                    JsValue::from_str(&format!("Failed to add {} to ZIP: {}", hist_zip_path, e))
                })?;
                zip.write_all(&hist_zip_data).map_err(|e| {
                    JsValue::from_str(&format!("Failed to write {}: {}", hist_zip_path, e))
                })?;
            }
        }

        zip.finish()
            .map_err(|e| JsValue::from_str(&format!("Failed to finish ZIP: {}", e)))?;
    }

    // Convert to base64 for JavaScript
    let base64_zip = general_purpose::STANDARD.encode(&zip_data);

    serde_wasm_bindgen::to_value(&serde_json::json!({
        "success": true,
        "filename": format!("{}.zip", filename),
        "data": base64_zip,
    }))
    .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)))
}
