use base64::Engine as _;
use base64::engine::general_purpose;
use drawckt::renderer::{Renderer, SymbolContexts};
use drawckt::schematic::{DesignId, LayerStyles, Schematic};
use indexmap::{IndexMap, IndexSet};
use serde::{Deserialize, Serialize};
use std::borrow::{Borrow, Cow};
use std::collections::HashMap;
use std::io::{Read, Write};
use std::iter::once;
use std::sync::Mutex;
use wasm_bindgen::prelude::*;
use zip::CompressionMethod;
use zip::read::ZipArchive;
use zip::write::{FileOptions, ZipWriter};

// Map of demo names to their JSON content (auto-generated by build.rs)
include!(concat!(env!("OUT_DIR"), "/demo_files.rs"));

// Initialize styles from static/style JSON files (auto-generated by build.rs)
include!(concat!(env!("OUT_DIR"), "/styles.rs"));

// Initialize panic hook and logger
#[wasm_bindgen(start)]
pub fn init() {
    console_error_panic_hook::set_once();
    console_log::init_with_level(log::Level::Info).expect("Failed to initialize logger");
}

// State management - store data in WASM
static APP_STATE: Mutex<Option<AppState>> = Mutex::new(None);

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AppState {
    pub schematic: Option<SchematicState>,
    pub styles: StylesState,
    pub symbols: Vec<SymbolData>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SchematicState {
    pub schematic: Schematic,
    pub history: HistoryContent,
    pub filename: String, // Original filename without extension
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StylesState {
    pub current: LayerStyles,
    pub current_name: String,
    pub all: IndexMap<String, LayerStyles>,
}

impl StylesState {
    pub fn new() -> Self {
        let all = init_styles();
        let current_name = "virtuoso".to_owned();
        Self {
            current: all[&current_name].clone(),
            current_name,
            all,
        }
    }
    pub fn all_names(&self) -> Vec<String> {
        self.all.keys().cloned().collect()
    }
    pub fn fix_current(&mut self) {
        self.all[&self.current_name] = self.current.clone();
    }
    pub fn add_style(&mut self, name: String, styles: LayerStyles) {
        self.fix_current();
        self.all.insert(name.clone(), styles);
        self.current_name = name;
    }
    pub fn get_current_fixed_style(&self) -> &LayerStyles {
        &self.all[&self.current_name]
    }
    pub fn get_current_style(&self) -> &LayerStyles {
        &self.current
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SymbolData {
    #[serde(flatten)]
    pub id: DesignId<'static>,
    pub history: HistoryContent,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HistoryContent {
    pub current_idx: usize,
    pub hist_content: Vec<String>,
}

impl HistoryContent {
    pub fn new(initial_content: String) -> Self {
        Self {
            current_idx: 0,
            hist_content: vec![initial_content],
        }
    }

    pub fn update(&mut self, content: String) {
        // Remove all history after current_idx
        self.hist_content.truncate(self.current_idx + 1);
        // Push new content to history
        self.hist_content.push(content);
        // Update current_idx
        self.current_idx += 1;
    }

    pub fn undo(&mut self) -> Result<(), String> {
        if self.current_idx > 0 {
            self.current_idx -= 1;
            Ok(())
        } else {
            Err("No history to undo".to_owned())
        }
    }

    pub fn redo(&mut self) -> Result<(), String> {
        if self.current_idx < self.hist_content.len() - 1 {
            self.current_idx += 1;
            Ok(())
        } else {
            Err("No history to redo".to_owned())
        }
    }

    pub fn get_current(&self) -> Option<&String> {
        self.hist_content.get(self.current_idx)
    }

    pub fn can_undo(&self) -> bool {
        self.current_idx > 0
    }

    pub fn can_redo(&self) -> bool {
        self.current_idx < self.hist_content.len() - 1
    }

    // Helper function to create history zip file
    pub fn hist_zip(&self, base_name: &str) -> Result<Vec<u8>, AppError> {
        let mut hist_zip_data = Vec::new();
        {
            let mut hist_zip = ZipWriter::new(std::io::Cursor::new(&mut hist_zip_data));
            let options = FileOptions::default()
                .compression_method(CompressionMethod::Deflated)
                .unix_permissions(0o755);

            // Add all history versions
            for (idx, content) in self.hist_content.iter().enumerate() {
                let file_idx = idx + 1; // 1-based index for file names
                let file_name = if idx == self.current_idx {
                    // Rename current version to .current.drawio
                    format!("{}.{}.current.drawio", base_name, file_idx)
                } else {
                    format!("{}.{}.drawio", base_name, file_idx)
                };

                hist_zip.start_file(&file_name, options)?;
                hist_zip.write_all(content.as_bytes())?;
            }

            hist_zip.finish()?;
        }
        Ok(hist_zip_data)
    }

    // Restore history from a history zip file
    pub fn from_hist_zip(hist_zip_data: &[u8], base_name: &str) -> Result<Self, AppError> {
        let cursor = std::io::Cursor::new(hist_zip_data);
        let mut archive = ZipArchive::new(cursor)?;

        let mut hist_content = Vec::new();
        let mut current_idx = 0;

        // Collect all files and sort by index
        let mut entries: Vec<(usize, String, bool)> = Vec::new();
        for i in 0..archive.len() {
            let file = archive.by_index(i)?;
            let name = file.name().to_owned();

            // Parse filename to extract index and check if it's current
            if name.starts_with(&format!("{}.", base_name)) && name.ends_with(".drawio") {
                let without_ext = name.strip_suffix(".drawio").unwrap();
                let is_current = without_ext.ends_with(".current");
                let index_str = if is_current {
                    without_ext
                        .strip_suffix(".current")
                        .unwrap()
                        .strip_prefix(&format!("{}.", base_name))
                        .unwrap()
                } else {
                    without_ext
                        .strip_prefix(&format!("{}.", base_name))
                        .unwrap()
                };

                if let Ok(file_idx) = index_str.parse::<usize>() {
                    entries.push((file_idx, name, is_current));
                }
            }
        }

        // Sort by index
        entries.sort_by_key(|(idx, _, _)| *idx);

        // Read files in order
        for (file_idx, name, is_current) in entries {
            let mut file = archive.by_name(&name)?;
            let mut content = String::new();
            file.read_to_string(&mut content)?;

            hist_content.push(content);

            // Track current index (0-based, so file_idx - 1)
            if is_current {
                current_idx = file_idx - 1;
            }
        }

        if hist_content.is_empty() {
            return Err(AppError::Message(
                "History ZIP contains no valid files".into(),
            ));
        }

        Ok(Self {
            current_idx,
            hist_content,
        })
    }
}

#[derive(Debug, thiserror::Error)]
pub enum AppError {
    #[error("Drawckt error: {0}")]
    Ckt(#[from] drawckt::DrawcktError),
    #[error("JSON parse error: {0}")]
    SerdeJson(#[from] serde_json::Error),
    #[error("WASM bindgen error: {0}")]
    SerdeWasmBindgen(#[from] serde_wasm_bindgen::Error),
    #[error("Base64 decode error: {0}")]
    Base64Decode(#[from] base64::DecodeError),
    #[error("ZIP error: {0}")]
    Zip(#[from] zip::result::ZipError),
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    #[error("UTF-8 decode error: {0}")]
    Utf8(#[from] std::string::FromUtf8Error),
    #[error("{0}")]
    Message(Cow<'static, str>),
}

// Manually implement the conversion
impl From<AppError> for JsValue {
    fn from(err: AppError) -> Self {
        JsValue::from_str(&err.to_string())
    }
}

// Response types for better performance (avoiding serde_json::json! intermediate step)
// Using references and Cow<str> to avoid unnecessary clones
#[derive(Serialize)]
struct SuccessResponse {
    success: bool,
}

#[derive(Serialize)]
struct SuccessWithMessageResponse<'a> {
    success: bool,
    #[serde(borrow)]
    message: Cow<'a, str>,
}

#[derive(Serialize)]
struct SuccessWithDataResponse {
    success: bool,
    symbol_count: usize,
    schematic_rendered: bool,
}

#[derive(Serialize)]
struct SuccessWithRestoredResponse {
    success: bool,
    symbol_count: usize,
    schematic_restored: bool,
}

#[derive(Serialize)]
struct ContentResponse<'a> {
    #[serde(borrow)]
    content: &'a str,
    #[serde(borrow)]
    lib: &'a str,
    #[serde(borrow)]
    cell: &'a str,
}

#[derive(Serialize)]
struct SchematicInfoResponse {
    current_idx: usize,
    hist_len: usize,
    can_undo: bool,
    can_redo: bool,
}

#[derive(Serialize)]
struct SymbolInfoResponse<'a> {
    #[serde(borrow)]
    lib: &'a str,
    #[serde(borrow)]
    cell: &'a str,
    current_idx: usize,
    hist_len: usize,
    can_undo: bool,
    can_redo: bool,
}

#[derive(Serialize)]
struct ExportResponse {
    success: bool,
    filename: String, // format!() creates owned String
    data: String,     // base64 encoding creates owned String
}

impl AppState {
    fn new() -> Self {
        Self {
            schematic: None,
            styles: StylesState::new(),
            symbols: Vec::default(),
        }
    }

    /// Execute a closure with read-only access to the state
    /// This avoids cloning the entire state
    fn with_state<F, R>(f: F) -> R
    where
        F: FnOnce(&AppState) -> R,
    {
        let mut state = APP_STATE.lock().unwrap();
        if state.is_none() {
            *state = Some(AppState::new());
        }
        f(state.as_ref().unwrap())
    }

    /// Execute a closure with mutable access to the state
    /// This avoids cloning the entire state
    fn with_state_mut<F, R>(f: F) -> R
    where
        F: FnOnce(&mut AppState) -> R,
    {
        let mut state = APP_STATE.lock().unwrap();
        if state.is_none() {
            *state = Some(AppState::new());
        }
        f(state.as_mut().unwrap())
    }

    fn symbol_contents<'a>(&'a self) -> Result<SymbolContexts<'a>, AppError> {
        Ok(SymbolContexts(
            self.symbols
                .iter()
                .map(|symbol_data| {
                    Ok((
                        symbol_data.id.refs(),
                        symbol_data
                            .history
                            .get_current()
                            .map(|content| content.as_str().into())
                            .ok_or_else(|| {
                                AppError::Message("Symbol content not available".into())
                            })?,
                    ))
                })
                .collect::<Result<_, AppError>>()?,
        ))
    }
}

// Main API functions
#[wasm_bindgen]
pub fn process_schematic_json(json_str: &str) -> Result<JsValue, AppError> {
    process_schematic_json_with_filename(json_str, None)
}

#[wasm_bindgen]
pub fn process_schematic_json_with_filename(
    json_str: &str,
    filename: Option<String>,
) -> Result<JsValue, AppError> {
    log::info!("Processing schematic JSON");

    let schematic: Schematic = serde_json::from_str(json_str)?;

    let symbol_count = AppState::with_state_mut(|state| -> Result<usize, AppError> {
        // Extract filename without extension
        let filename_without_ext = if let Some(ref fname) = filename {
            fname.strip_suffix(".json").unwrap_or(fname).to_owned()
        } else {
            // Use design name as default
            format!("{}_{}", schematic.design.lib, schematic.design.cell)
        };

        // Render symbols
        log::info!("Rendering symbols");
        let renderer = Renderer::new(&schematic, state.styles.get_current_style());

        let symbol_contexts = renderer.render_symbols_file().map_err(AppError::Ckt)?;

        // Render schematic
        log::info!("Rendering schematic");
        let schematic_content = renderer
            .render_schematic_file(&symbol_contexts)
            .map_err(AppError::Ckt)?;

        // Convert SymbolContexts to serializable format
        state.symbols = symbol_contexts
            .0
            .into_iter()
            .filter_map(|(symbol_id, content)| {
                // Skip invalid symbols (empty lib or cell)
                if symbol_id.lib.is_empty() || symbol_id.cell.is_empty() {
                    log::warn!("Skipping symbol with empty lib or cell: {:?}", symbol_id);
                    None
                } else {
                    Some(SymbolData {
                        id: symbol_id.owned(),
                        history: HistoryContent::new(content.into_owned()),
                    })
                }
            })
            .collect();
        state.schematic = Some(SchematicState {
            schematic,
            history: HistoryContent::new(schematic_content),
            filename: filename_without_ext,
        });

        Ok(state.symbols.len())
    })?;

    let result = serde_wasm_bindgen::to_value(&SuccessWithDataResponse {
        success: true,
        symbol_count,
        schematic_rendered: true,
    })?;

    log::debug!("Schematic processing complete");
    Ok(result)
}

#[wasm_bindgen]
pub fn process_schematic_zip(base64_zip: &str) -> Result<JsValue, AppError> {
    process_schematic_zip_with_filename(base64_zip, None)
}

/// Extract ZIP archive and return file contents
fn extract_zip_contents(
    base64_zip: &str,
) -> Result<(HashMap<String, Vec<u8>>, Option<String>), AppError> {
    log::info!("Processing schematic ZIP");
    // Decode base64
    let zip_data = general_purpose::STANDARD.decode(base64_zip)?;

    // Open ZIP archive
    let cursor = std::io::Cursor::new(zip_data);
    let mut archive = ZipArchive::new(cursor)?;

    // Read all files into memory first to avoid multiple borrows
    let file_contents: HashMap<String, Vec<u8>> = (0..archive.len())
        .into_iter()
        .map(|i| {
            let mut file = archive.by_index(i)?;
            let name = file.name().to_owned();
            let mut content = Vec::new();
            file.read_to_end(&mut content)?;
            Ok((name, content))
        })
        .collect::<Result<HashMap<String, Vec<u8>>, AppError>>()?;
    let base_path = detect_base_path(&file_contents);
    log::info!(
        "Detected base path: '{}'",
        if let Some(path) = &base_path {
            path.as_str()
        } else {
            "root"
        }
    );
    Ok((file_contents, base_path))
}

/// Detect the base path prefix for files in the ZIP
/// Returns the prefix (e.g., "folder/" or "") based on the ZIP structure
/// Supports two formats:
/// 1. Files directly in root: layers.json, schematic.json, ...
/// 2. Files in a subfolder: folder/layers.json, folder/schematic.json, ...
fn detect_base_path(file_contents: &std::collections::HashMap<String, Vec<u8>>) -> Option<String> {
    // Check if files are directly in root
    let root_files = [
        "layers.json",
        "schematic.json",
        "schematic.hist.zip",
        "schematic.drawio",
    ];
    for root_file in &root_files {
        if file_contents.contains_key(*root_file) {
            return None; // Files are in root
        }
    }

    // Check if files are in a subfolder
    // Find the first directory that contains one of our target files
    for name in file_contents.keys() {
        // Skip directories and files in symbols/ folder
        if name.ends_with('/') || name.starts_with("symbols/") {
            continue;
        }

        // Extract the first directory component
        if let Some(first_slash) = name.find('/') {
            let potential_base = &name[..first_slash + 1];
            // Check if this directory contains our target files
            for root_file in &root_files {
                let path_in_dir = format!("{}{}", potential_base, root_file);
                if file_contents.contains_key(&path_in_dir) {
                    return Some(potential_base.to_owned());
                }
            }
        }
    }

    // Default: assume files are in root
    None
}

/// Find a file in the ZIP using the base path prefix
fn find_file(
    file_contents: &mut std::collections::HashMap<String, Vec<u8>>,
    base_path: &Option<String>,
    filename: &str,
) -> Option<Vec<u8>> {
    // Try with base path first
    let path_with_base = if let Some(base_path) = base_path {
        Cow::Owned(format!("{}{}", base_path, filename))
    } else {
        Cow::Borrowed(filename)
    };
    if let Some(content) = file_contents.remove(path_with_base.as_ref()) {
        return Some(content);
    }
    // Fallback: try without base path (for root files)
    file_contents.remove(filename)
}

#[wasm_bindgen]
pub fn process_schematic_zip_with_filename(
    base64_zip: &str,
    filename: Option<String>,
) -> Result<JsValue, AppError> {
    let (mut file_contents, base_path) = extract_zip_contents(base64_zip)?;
    let mut state = AppState::new();

    // Read styles from /styles directory
    // First, try to read /styles/{current_name}.json for current style
    // Then read /styles/all/{name}.json for all styles
    let mut styles_state = StylesState::new();

    // Collect style file names first to avoid borrow checker issues
    let mut all_style_files = Vec::new();
    let mut current_style_file = None;
    for name in file_contents.keys() {
        if name.starts_with("styles/all/") && name.ends_with(".json") {
            all_style_files.push(name.clone());
        } else if name.starts_with("styles/")
            && name.ends_with(".json")
            && !name.starts_with("styles/all/")
        {
            current_style_file = Some(name.clone());
        }
    }

    // Read all styles from /styles/all/ directory
    let mut all_styles = IndexMap::new();
    for name in &all_style_files {
        if let Some(name_without_ext) = name
            .strip_prefix("styles/all/")
            .and_then(|s| s.strip_suffix(".json"))
        {
            if let Some(content) = find_file(&mut file_contents, &base_path, name) {
                let style_json = String::from_utf8(content)?;
                let layer_styles: LayerStyles = serde_json::from_str(&style_json)?;
                all_styles.insert(name_without_ext.to_owned(), layer_styles);
            }
        }
    }

    // If we found styles in /styles/all/, use them
    if !all_styles.is_empty() {
        styles_state.all = all_styles;
    }

    // Try to read current style from /styles/{current_name}.json
    if let Some(name) = current_style_file {
        if let Some(name_without_ext) = name
            .strip_prefix("styles/")
            .and_then(|s| s.strip_suffix(".json"))
        {
            if let Some(content) = find_file(&mut file_contents, &base_path, &name) {
                let style_json = String::from_utf8(content)?;
                let layer_styles: LayerStyles = serde_json::from_str(&style_json)?;
                let current_name = name_without_ext.to_owned();
                styles_state.current = layer_styles.clone();
                styles_state.current_name = current_name.clone();
                // Also add to all if not present
                if !styles_state.all.contains_key(&current_name) {
                    styles_state.all.insert(current_name, layer_styles);
                }
            }
        }
    }

    // Fallback: if no styles found, try old layers.json format
    if styles_state.all.is_empty() {
        if let Some(layers_data) = find_file(&mut file_contents, &base_path, "layers.json") {
            let layers_json = String::from_utf8(layers_data)?;
            let layer_styles: LayerStyles = serde_json::from_str(&layers_json)?;
            styles_state.current = layer_styles.clone();
            styles_state.current_name = "custom".to_owned();
            styles_state.all.insert("custom".to_owned(), layer_styles);
            log::info!("Restored layer styles from old layers.json format");
        }
    } else {
        log::info!("Restored styles from /styles directory");
    }

    state.styles = styles_state;

    // Read schematic.json
    let schematic_data = find_file(&mut file_contents, &base_path, "schematic.json")
        .ok_or_else(|| AppError::Message("Failed to find schematic.json in ZIP".into()))?;
    let schematic_json = String::from_utf8(schematic_data)?;
    let schematic: Schematic = serde_json::from_str(&schematic_json)?;

    // Extract filename
    let filename_without_ext = if let Some(ref fname) = filename {
        fname
            .strip_suffix(".zip")
            .or_else(|| fname.strip_suffix(".json"))
            .unwrap_or(fname)
            .to_owned()
    } else {
        format!("{}_{}", schematic.design.lib, schematic.design.cell)
    };

    // Read schematic.hist.zip if present
    let schematic_history = if let Some(hist_zip_data) =
        find_file(&mut file_contents, &base_path, "schematic.hist.zip")
    {
        let history = HistoryContent::from_hist_zip(&hist_zip_data, "schematic")?;
        log::info!("Restored schematic history from ZIP");
        history
    } else if let Some(drawio_content) =
        find_file(&mut file_contents, &base_path, "schematic.drawio")
    {
        // Fallback: read schematic.drawio if hist.zip is not available
        let drawio_str = String::from_utf8(drawio_content)?;
        log::info!("Restored schematic from schematic.drawio (no history)");
        HistoryContent::new(drawio_str)
    } else {
        return Err(AppError::Message(
            "No schematic content found in ZIP".into(),
        ));
    };

    state.symbols = schematic
        .symbols
        .iter()
        .map(|symbol| {
            let lib = &symbol.id.lib;
            let cell = &symbol.id.cell;
            // Read symbol drawio file
            // find_file will try base_path + symbols/lib/cell.drawio first, then symbols/lib/cell.drawio
            let symbol_path = format!("symbols/{}/{}.drawio", lib, cell);
            let symbol_content = find_file(&mut file_contents, &base_path, &symbol_path)
                .ok_or_else(|| {
                    AppError::Message(format!("Failed to find {} in ZIP", symbol_path).into())
                })?;
            let symbol_content_str = String::from_utf8(symbol_content)?;
            // Read symbol history zip if present
            let hist_zip_path = format!("symbols/{}/{}.hist.zip", lib, cell);
            let history = if let Some(hist_zip_data) =
                find_file(&mut file_contents, &base_path, &hist_zip_path)
            {
                HistoryContent::from_hist_zip(&hist_zip_data, &cell)?
            } else {
                // Fallback: use drawio content as initial history
                HistoryContent::new(symbol_content_str)
            };
            Ok(SymbolData {
                id: symbol.id.clone(),
                history,
            })
        })
        .collect::<Result<Vec<SymbolData>, AppError>>()?;
    state.schematic = Some(SchematicState {
        schematic,
        history: schematic_history,
        filename: filename_without_ext,
    });

    let symbol_count = state.symbols.len();
    AppState::with_state_mut(|s| *s = state);

    let result = serde_wasm_bindgen::to_value(&SuccessWithRestoredResponse {
        success: true,
        symbol_count,
        schematic_restored: true,
    })?;
    log::debug!("Schematic ZIP processing complete");
    Ok(result)
}

#[wasm_bindgen]
pub fn get_symbol_content(lib: &str, cell: &str) -> Result<JsValue, AppError> {
    log::debug!("Getting symbol content: {}/{}", lib, cell);

    AppState::with_state(|state| -> Result<JsValue, AppError> {
        for symbol in &state.symbols {
            if symbol.id.lib == lib && symbol.id.cell == cell {
                if let Some(content) = symbol.history.get_current() {
                    return Ok(JsValue::from_str(content));
                }
            }
        }
        Err(AppError::Message(
            format!("Symbol {lib}/{cell} not found").into(),
        ))
    })
}

// Internal helper to get schematic content as string (for viewer)

fn get_schematic_content_string() -> Result<JsValue, AppError> {
    AppState::with_state(|state| {
        if let Some(schematic_state) = &state.schematic
            && let Some(content) = schematic_state.history.get_current()
        {
            Ok(JsValue::from_str(content))
        } else {
            Err(AppError::Message("Schematic content not available".into()))
        }
    })
}

#[wasm_bindgen]
pub fn get_schematic_content() -> Result<JsValue, AppError> {
    log::debug!("Getting schematic content");
    AppState::with_state(|state| -> Result<JsValue, AppError> {
        if let Some(schematic_state) = &state.schematic
            && let Some(content) = schematic_state.history.get_current()
        {
            let lib: &str = &schematic_state.schematic.design.lib;
            let cell: &str = &schematic_state.schematic.design.cell;
            serde_wasm_bindgen::to_value(&ContentResponse { content, lib, cell })
                .map_err(AppError::SerdeWasmBindgen)
        } else {
            Err(AppError::Message("Schematic content not available".into()))
        }
    })
}

#[wasm_bindgen]
pub fn get_all_symbols() -> Result<JsValue, AppError> {
    log::debug!("Getting all symbols");

    AppState::with_state(|state| -> Result<JsValue, AppError> {
        // Filter out invalid symbols and convert to SymbolInfo structs
        let symbols: Vec<DesignId<'static>> = state
            .symbols
            .iter()
            .filter(|s| !s.id.lib.is_empty() && !s.id.cell.is_empty())
            .map(|s| s.id.owned())
            .collect();
        log::debug!("Returning {} symbols", symbols.len());
        Ok(serde_wasm_bindgen::to_value(&symbols)?)
    })
}

#[wasm_bindgen]
pub fn update_layer_styles(styles_json: &str) -> Result<JsValue, AppError> {
    log::debug!("Updating layer styles");

    let new_styles: LayerStyles = serde_json::from_str(styles_json)?;

    AppState::with_state_mut(|state| -> Result<(), AppError> {
        state.apply_style_update(&new_styles)?;
        state.styles.current = new_styles;
        Ok(())
    })?;

    Ok(serde_wasm_bindgen::to_value(&SuccessResponse {
        success: true,
    })?)
}

#[wasm_bindgen]
pub fn get_layer_styles() -> Result<JsValue, AppError> {
    AppState::with_state(|state| -> Result<JsValue, AppError> {
        Ok(serde_wasm_bindgen::to_value(
            state.styles.get_current_style(),
        )?)
    })
}

#[wasm_bindgen]
pub fn get_current_fixed_layer_styles() -> Result<JsValue, AppError> {
    AppState::with_state(|state| -> Result<JsValue, AppError> {
        Ok(serde_wasm_bindgen::to_value(
            state.styles.get_current_fixed_style(),
        )?)
    })
}

#[wasm_bindgen]
pub fn update_symbol_content(lib: &str, cell: &str, content: String) -> Result<JsValue, AppError> {
    log::info!("Updating symbol content: {}/{}", lib, cell);

    let symbol_mapping = once(DesignId {
        lib: Cow::Borrowed(lib),
        cell: Cow::Borrowed(cell),
    })
    .collect::<IndexSet<_>>();

    AppState::with_state_mut(|state| -> Result<(), AppError> {
        let schematic_state = state
            .schematic
            .as_mut()
            .ok_or_else(|| AppError::Message("Schematic not found".into()))?;
        let schematic_content = Renderer::update_symbol_content(
            schematic_state
                .history
                .get_current()
                .ok_or_else(|| AppError::Message("Schematic not rendered yet".into()))?,
            &content,
            &symbol_mapping,
            &schematic_state.schematic,
            &state.styles.get_current_style(),
        )
        .map_err(AppError::Ckt)?;
        schematic_state.history.update(schematic_content);

        let mut found = false;
        for symbol in &mut state.symbols {
            if symbol_mapping.contains(&symbol.id) {
                symbol.history.update(content.clone());
                found = true;
            }
        }

        if !found {
            return Err(AppError::Message(
                format!("Symbol {lib}/{cell} not found").into(),
            ));
        }

        Ok(())
    })?;

    Ok(serde_wasm_bindgen::to_value(&SuccessWithMessageResponse {
        success: true,
        message: Cow::Owned(format!("Symbol {}/{} updated", lib, cell)),
    })?)
}

#[wasm_bindgen]
pub fn undo_symbol(lib: &str, cell: &str) -> Result<JsValue, AppError> {
    log::info!("Undoing symbol: {}/{}", lib, cell);

    AppState::with_state_mut(|state| {
        // Find and undo the symbol
        let mut found = false;
        for symbol in &mut state.symbols {
            if symbol.id.lib == lib && symbol.id.cell == cell {
                match symbol.history.undo() {
                    Ok(_) => {
                        found = true;
                        break;
                    }
                    Err(e) => {
                        return Err(AppError::Message(
                            format!("Symbol {lib}/{cell}: {e}").into(),
                        ));
                    }
                }
            }
        }

        if !found {
            return Err(AppError::Message(
                format!("Symbol {lib}/{cell} not found").into(),
            ));
        }

        // Re-render symbol and schematic
        if let Some(ref schematic_state) = state.schematic {
            log::info!("Re-rendering symbol and schematic after undo");
            let symbol_contents = state.symbol_contents()?;
            let renderer =
                Renderer::new(&schematic_state.schematic, state.styles.get_current_style());

            let schematic_content = renderer
                .render_schematic_file(&symbol_contents)
                .map_err(AppError::Ckt)?;

            // Update schematic history
            if let Some(ref mut schematic_state) = state.schematic {
                schematic_state.history.update(schematic_content);
            }
        }

        Ok(())
    })?;

    serde_wasm_bindgen::to_value(&SuccessWithMessageResponse {
        success: true,
        message: Cow::Owned(format!("Symbol {}/{} undone", lib, cell)),
    })
    .map_err(AppError::SerdeWasmBindgen)
}

#[wasm_bindgen]
pub fn redo_symbol(lib: &str, cell: &str) -> Result<JsValue, AppError> {
    log::info!("Redoing symbol: {lib}/{cell}");

    AppState::with_state_mut(|state| {
        // Find and redo the symbol
        let mut found = false;
        for symbol in &mut state.symbols {
            if symbol.id.lib == lib && symbol.id.cell == cell {
                match symbol.history.redo() {
                    Ok(_) => {
                        found = true;
                        break;
                    }
                    Err(e) => {
                        return Err(AppError::Message(
                            format!("Symbol {lib}/{cell}: {e}").into(),
                        ));
                    }
                }
            }
        }

        if !found {
            return Err(AppError::Message(
                format!("Symbol {lib}/{cell} not found").into(),
            ));
        }

        // Re-render symbol and schematic
        if let Some(ref schematic_state) = state.schematic {
            log::info!("Re-rendering symbol and schematic after redo");
            let symbol_contents = state.symbol_contents()?;
            let renderer =
                Renderer::new(&schematic_state.schematic, state.styles.get_current_style());

            let schematic_content = renderer
                .render_schematic_file(&symbol_contents)
                .map_err(AppError::Ckt)?;

            // Update schematic history
            if let Some(ref mut schematic_state) = state.schematic {
                schematic_state.history.update(schematic_content);
            }
        }

        Ok(())
    })?;

    serde_wasm_bindgen::to_value(&SuccessWithMessageResponse {
        success: true,
        message: Cow::Owned(format!("Symbol {}/{} redone", lib, cell)),
    })
    .map_err(AppError::SerdeWasmBindgen)
}

#[wasm_bindgen]
pub fn get_symbol_info(lib: &str, cell: &str) -> Result<JsValue, AppError> {
    log::debug!("Getting symbol info: {}/{}", lib, cell);

    AppState::with_state(|state| {
        for symbol in &state.symbols {
            if symbol.id.lib == lib && symbol.id.cell == cell {
                return serde_wasm_bindgen::to_value(&SymbolInfoResponse {
                    lib: symbol.id.lib.borrow(),
                    cell: symbol.id.cell.borrow(),
                    current_idx: symbol.history.current_idx,
                    hist_len: symbol.history.hist_content.len(),
                    can_undo: symbol.history.can_undo(),
                    can_redo: symbol.history.can_redo(),
                })
                .map_err(AppError::SerdeWasmBindgen);
            }
        }

        Err(AppError::Message(
            format!("Symbol {lib}/{cell} not found").into(),
        ))
    })
}

impl AppState {
    fn update_schematic_content(&mut self, content: String) {
        log::info!("Updating schematic content");

        // Update schematic history
        if let Some(schematic_state) = &mut self.schematic {
            schematic_state.history.update(content);
        } else {
            // This shouldn't happen, but handle it gracefully
            log::warn!("Attempted to update schematic content but no schematic is loaded");
        }
    }

    /// Apply style update to all symbols and schematic content
    /// This uses Renderer::update_style to efficiently update existing content
    /// instead of re-rendering from scratch
    fn apply_style_update(&mut self, new_styles: &LayerStyles) -> Result<(), AppError> {
        let old_styles = self.styles.get_current_style();

        // Update all symbols
        for symbol in &mut self.symbols {
            if let Some(content) = symbol.history.get_current() {
                let new_content = Renderer::update_style(content, old_styles, new_styles)
                    .map_err(AppError::Ckt)?;
                symbol.history.update(new_content);
            }
        }

        // Update schematic content
        if let Some(schematic_state) = &mut self.schematic
            && let Some(content) = schematic_state.history.get_current()
        {
            let new_content =
                Renderer::update_style(content, old_styles, new_styles).map_err(AppError::Ckt)?;
            schematic_state.history.update(new_content);
        }

        Ok(())
    }
}

#[wasm_bindgen]
pub fn update_schematic_content(content: String) -> Result<JsValue, AppError> {
    AppState::with_state_mut(|state| {
        state.update_schematic_content(content);
    });

    Ok(serde_wasm_bindgen::to_value(&SuccessWithMessageResponse {
        success: true,
        message: Cow::Borrowed("Schematic updated"),
    })?)
}

#[wasm_bindgen]
pub fn undo_schematic() -> Result<JsValue, AppError> {
    log::info!("Undoing schematic");

    AppState::with_state_mut(|state| {
        match state.schematic.as_mut() {
            Some(schematic_state) => {
                schematic_state
                    .history
                    .undo()
                    .map_err(|e| AppError::Message(e.into()))?;
            }
            None => {
                return Err(AppError::Message("Schematic not rendered yet".into()));
            }
        }

        // Content is already in history, no need to re-render
        Ok(())
    })?;

    serde_wasm_bindgen::to_value(&SuccessWithMessageResponse {
        success: true,
        message: Cow::Borrowed("Schematic undone"),
    })
    .map_err(AppError::SerdeWasmBindgen)
}

#[wasm_bindgen]
pub fn redo_schematic() -> Result<JsValue, AppError> {
    log::info!("Redoing schematic");

    AppState::with_state_mut(|state| {
        match state.schematic.as_mut() {
            Some(schematic_state) => {
                schematic_state
                    .history
                    .redo()
                    .map_err(|e| AppError::Message(e.into()))?;
            }
            None => {
                return Err(AppError::Message("Schematic not rendered yet".into()));
            }
        }

        // Content is already in history, no need to re-render
        Ok(())
    })?;

    serde_wasm_bindgen::to_value(&SuccessWithMessageResponse {
        success: true,
        message: Cow::Borrowed("Schematic redone"),
    })
    .map_err(AppError::SerdeWasmBindgen)
}

#[wasm_bindgen]
pub fn get_schematic_info() -> Result<JsValue, AppError> {
    log::debug!("Getting schematic info");

    AppState::with_state(|state| match &state.schematic {
        Some(schematic_state) => serde_wasm_bindgen::to_value(&SchematicInfoResponse {
            current_idx: schematic_state.history.current_idx,
            hist_len: schematic_state.history.hist_content.len(),
            can_undo: schematic_state.history.can_undo(),
            can_redo: schematic_state.history.can_redo(),
        })
        .map_err(AppError::SerdeWasmBindgen),
        None => Err(AppError::Message("Schematic not rendered yet".into())),
    })
}

#[wasm_bindgen]
pub fn get_styles_state() -> Result<JsValue, AppError> {
    AppState::with_state(|state| {
        serde_wasm_bindgen::to_value(&state.styles).map_err(AppError::SerdeWasmBindgen)
    })
}

#[wasm_bindgen]
pub fn get_all_style_names() -> Result<JsValue, AppError> {
    AppState::with_state(|state| {
        serde_wasm_bindgen::to_value(&state.styles.all_names()).map_err(AppError::SerdeWasmBindgen)
    })
}

#[wasm_bindgen]
pub fn set_current_style(name: &str) -> Result<JsValue, AppError> {
    AppState::with_state_mut(|state| {
        if !state.styles.all.contains_key(name) {
            return Err(AppError::Message(
                format!("Style '{name}' not found").into(),
            ));
        }

        state.styles.fix_current();
        let new_styles = state.styles.all[name].clone();
        state.styles.current_name = name.to_owned();

        // Apply style update using the same logic as update_layer_styles
        state.apply_style_update(&new_styles)?;
        state.styles.current = new_styles;

        Ok(())
    })?;

    serde_wasm_bindgen::to_value(&SuccessResponse { success: true })
        .map_err(AppError::SerdeWasmBindgen)
}

#[wasm_bindgen]
pub fn add_style(name: &str, styles_json: &str) -> Result<JsValue, AppError> {
    let styles: LayerStyles = serde_json::from_str(styles_json).map_err(AppError::SerdeJson)?;

    AppState::with_state_mut(|state| -> Result<(), AppError> {
        state.styles.add_style(name.to_owned(), styles.clone());

        // Apply style update using the same logic as update_layer_styles
        state.apply_style_update(&styles)?;
        state.styles.current = styles;

        Ok(())
    })?;

    Ok(serde_wasm_bindgen::to_value(&SuccessResponse {
        success: true,
    })?)
}

#[wasm_bindgen]
pub fn reset_current_style() -> Result<JsValue, AppError> {
    AppState::with_state_mut(|state| -> Result<(), AppError> {
        let new_styles = state.styles.get_current_fixed_style().clone();

        // Apply style update using the same logic as update_layer_styles
        state.apply_style_update(&new_styles)?;
        state.styles.current = new_styles;

        Ok(())
    })?;

    Ok(serde_wasm_bindgen::to_value(&SuccessResponse {
        success: true,
    })?)
}

#[wasm_bindgen]
pub fn fix_current_style() -> Result<JsValue, AppError> {
    AppState::with_state_mut(|state| {
        state.styles.fix_current();
    });

    serde_wasm_bindgen::to_value(&SuccessResponse { success: true })
        .map_err(AppError::SerdeWasmBindgen)
}

// Router function for embedded files
#[wasm_bindgen]
pub fn route_embedded(path: &str) -> Result<JsValue, AppError> {
    log::debug!("Routing embedded path: {}", path);

    // Extract the embedded part from path (supports subfolder deployment)
    // Path might be like /path/to/drawckt/embedded/schematic.drawio
    // or /embedded/schematic.drawio
    let embedded_part = if let Some(idx) = path.rfind("/embedded/") {
        &path[idx..]
    } else if path.starts_with("/embedded/") {
        path
    } else {
        return Err(AppError::Message(
            format!("Invalid path: no /embedded/ found in {path}").into(),
        ));
    };

    // Parse path: /embedded/symbols/{lib}/{cell}.drawio or /embedded/schematic.drawio
    if embedded_part == "/embedded/schematic.drawio"
        || embedded_part.starts_with("/embedded/schematic.drawio")
    {
        return get_schematic_content_string();
    }

    if embedded_part.starts_with("/embedded/symbols/") {
        // Remove prefix and suffix
        let without_prefix = embedded_part
            .strip_prefix("/embedded/symbols/")
            .ok_or_else(|| AppError::Message("Invalid path: missing prefix".into()))?;

        // Remove .drawio suffix if present
        let without_suffix = if without_prefix.ends_with(".drawio") {
            without_prefix
                .strip_suffix(".drawio")
                .ok_or_else(|| AppError::Message("Invalid path: missing suffix".into()))?
        } else {
            without_prefix
        };

        // Split by '/' to get lib and cell
        let parts: Vec<&str> = without_suffix.split('/').collect();

        log::debug!("Path parts: {:?}, count: {}", parts, parts.len());

        if parts.len() == 2 {
            let lib = parts[0];
            let cell = parts[1];
            log::debug!("Getting symbol: lib={}, cell={}", lib, cell);
            return get_symbol_content(lib, cell);
        } else {
            log::warn!("Invalid path format: expected 2 parts, got {}", parts.len());
            return Err(AppError::Message(
                format!(
                    "Invalid path format: expected lib/cell, got {} parts",
                    parts.len()
                )
                .into(),
            ));
        }
    }

    Err(AppError::Message(format!("Unknown path: {path}").into()))
}

#[wasm_bindgen]
pub fn get_demo_list() -> Result<JsValue, AppError> {
    log::debug!("Getting demo list");

    let demo_names: Vec<&str> = DEMO_FILES.keys().copied().collect();

    serde_wasm_bindgen::to_value(&demo_names).map_err(AppError::SerdeWasmBindgen)
}

#[wasm_bindgen]
pub fn load_demo(name: &str) -> Result<JsValue, AppError> {
    log::debug!("Loading demo: {}", name);
    let content = DEMO_FILES
        .get(name)
        .ok_or_else(|| AppError::Message(format!("Demo '{name}' not found").into()))?;
    Ok(JsValue::from_str(content))
}

#[wasm_bindgen]
pub fn export_all_files() -> Result<JsValue, AppError> {
    log::info!("Exporting all files to ZIP");

    AppState::with_state(|state| {
        // Check if schematic is available
        let schematic_state = state
            .schematic
            .as_ref()
            .ok_or_else(|| AppError::Message("No schematic loaded".into()))?;

        let schematic_content = schematic_state
            .history
            .get_current()
            .ok_or_else(|| AppError::Message("Schematic not rendered".into()))?;

        // Get filename
        let filename = schematic_state.filename.clone();

        // Create ZIP in memory
        let mut zip_data = Vec::new();
        {
            let mut zip = ZipWriter::new(std::io::Cursor::new(&mut zip_data));
            let options = FileOptions::default()
                .compression_method(CompressionMethod::Deflated)
                .unix_permissions(0o755);

            // Add styles to /styles directory
            // Save current style as /styles/{current_name}.json
            let current_style_json =
                serde_json::to_string_pretty(state.styles.get_current_style())?;
            let current_style_path = format!("styles/{}.json", state.styles.current_name);
            zip.start_file(&current_style_path, options)?;
            zip.write_all(current_style_json.as_bytes())?;

            // Save all styles to /styles/all/{name}.json
            for (name, style) in &state.styles.all {
                let style_json = serde_json::to_string_pretty(style)?;
                let style_path = format!("styles/all/{}.json", name);
                zip.start_file(&style_path, options)?;
                zip.write_all(style_json.as_bytes())?;
            }

            // Add schematic.json
            let schematic_json = serde_json::to_string_pretty(&schematic_state.schematic)?;
            zip.start_file("schematic.json", options)?;
            zip.write_all(schematic_json.as_bytes())?;

            // Add schematic.drawio
            zip.start_file("schematic.drawio", options)?;
            zip.write_all(schematic_content.as_bytes())?;

            // Add schematic.hist.zip
            let hist_zip_data = schematic_state.history.hist_zip("schematic")?;
            zip.start_file("schematic.hist.zip", options)?;
            zip.write_all(&hist_zip_data)?;

            // Add symbols directory
            for symbol_data in &state.symbols {
                // Get current content from history
                if let Some(content) = symbol_data.history.get_current() {
                    let symbol_path = format!(
                        "symbols/{}/{}.drawio",
                        symbol_data.id.lib, symbol_data.id.cell
                    );
                    zip.start_file(&symbol_path, options)?;
                    zip.write_all(content.as_bytes())?;

                    // Add symbol history zip
                    let hist_zip_data = symbol_data.history.hist_zip(&symbol_data.id.cell)?;
                    let hist_zip_path = format!(
                        "symbols/{}/{}.hist.zip",
                        symbol_data.id.lib, symbol_data.id.cell
                    );
                    zip.start_file(&hist_zip_path, options)?;
                    zip.write_all(&hist_zip_data)?;
                }
            }

            zip.finish()?;
        }

        // Convert to base64 for JavaScript
        let base64_zip = general_purpose::STANDARD.encode(&zip_data);

        Ok(serde_wasm_bindgen::to_value(&ExportResponse {
            success: true,
            filename: format!("{}.zip", filename),
            data: base64_zip,
        })?)
    })
}
